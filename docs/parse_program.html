<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>paroxython.parse_program API documentation</title>
<meta name="description" content="Search a program for the features specified in `spec.md`." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<a href="https://github.com/laowantong/paroxython"><img style="position: absolute; top: 0; right: 0; border: 0; width: 150px; height: 150px" src="https://laowantong.github.io/paroxython/resources/source_on_github.png" alt="Source on GitHub"></a>
<style>.homelink{display:block}.homelink:hover{color:inherit}.homelink img{margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://laowantong.github.io/paroxython/parse_program.html">
<link rel="icon" href="https://laowantong.github.io/paroxython/resources/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>paroxython.parse_program</code></h1>
</header>
<section id="section-intro">
<p>Search a program for the features specified in <a href="https://github.com/laowantong/paroxython/blob/master/paroxython/resources/spec.md"><code>spec.md</code></a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/parse_program.py#L0-L374" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">from collections import defaultdict
from os.path import dirname
from pathlib import Path
from time import perf_counter
from typing import Callable, Dict, Iterator, List, Tuple

import regex  # type: ignore

from .derived_labels_db import DerivedLabelsDatabase
from .flatten_ast import ast, flatten_ast
from .goodies import print_fail
from .user_types import Label, LabelName, Labels, LabelsSpans, Program, Query, Source, Span

__pdoc__ = {
    &#34;ProgramParser&#34;: &#34;&#34;,
    &#34;ProgramParser.__init__&#34;: True,
    &#34;ProgramParser.__call__&#34;: True,
    &#34;foobar&#34;: True,
}


def find_all_features(
    specifications: str,
    find_all: Callable = regex.compile(
        r&#34;(?ms)&#34;
        r&#34;^\#{4}\s+Feature\s+`(.+?)`&#34;  # capture the label&#39;s pattern
        r&#34;.+?\#{5}\s+Specification&#34;  # ensure the sequel is in the Specification section
        r&#34;.+?```(.*?)\n+(.*?)\n?```&#34;  # capture the language and the specification
    ).findall,
) -&gt; Iterator[Tuple[LabelName, str, str]]:
    return find_all(specifications)


def pos_to_span(pos: List[str]) -&gt; Span:
    (start, path) = pos[0].split(&#34;:&#34;)
    (end, _) = pos[-1].split(&#34;:&#34;)
    return Span(int(start), int(end), path)


DEFAULT_SPEC_PATH = Path(dirname(__file__)) / &#34;resources&#34; / &#34;spec.md&#34;


def get_bindings(
    label_prefix: LabelName, captures: Dict[str, List[str]]
) -&gt; Iterator[Tuple[LabelName, Span]]:
    if captures.get(&#34;SUFFIX&#34;):
        # There is a &#34;SUFFIX&#34; key and its value is not `[]`.
        if len(captures[&#34;POS&#34;]) == len(captures[&#34;SUFFIX&#34;]):
            # When there are as many matched positions as suffixes, associate them in parallel.
            for (suffix, pos) in zip(captures[&#34;SUFFIX&#34;], captures[&#34;POS&#34;]):
                yield (LabelName(f&#34;{label_prefix}:{suffix}&#34;), pos_to_span([pos]))
        else:
            # When there are more or less matched positions than suffixes, interpret the positions
            # as defining a unique span, and associate it with each suffix.
            span = pos_to_span(captures[&#34;POS&#34;])
            for suffix in captures[&#34;SUFFIX&#34;]:
                yield (LabelName(f&#34;{label_prefix}:{suffix}&#34;), span)
    else:
        # There is no &#34;SUFFIX&#34; key or its value is `[]`.
        yield (label_prefix, pos_to_span(captures[&#34;POS&#34;]))


class ProgramParser:
    def __init__(self, spec_path: Path = DEFAULT_SPEC_PATH) -&gt; None:
        self.spec_path = spec_path
        text = self.spec_path.read_text()
        self.features: Dict[LabelName, regex.Pattern] = {}
        self.queries: Dict[LabelName, Query] = {}
        self.times: Dict[LabelName, float] = {LabelName(&#34;TOTAL&#34;): 0.0}
        for (label_name, language, specification) in find_all_features(text):
            if label_name in self.features:  # pragma: no cover
                print_fail(f&#34;Duplicated name &#39;{label_name}&#39;!&#34;)
            self.times[label_name] = 0.0
            if language == &#34;re&#34;:
                self.features[label_name] = regex.compile(f&#34;(?mx){specification}&#34;).finditer
            elif language == &#34;sql&#34;:
                self.queries[label_name] = Query(specification)
            elif specification.strip() != &#34;&#34;:  # pragma: no cover
                print_fail(f&#34;Unknow language &#39;{language}&#39; for &#39;{label_name}&#39;!&#34;)
        self.derived_labels_database = DerivedLabelsDatabase()

    def __call__(self, program: Program, yield_failed_matches: bool = False) -&gt; Labels:
        # If the program can be parsed and is nonempty, flatten its AST.
        try:
            tree = ast.parse(program.source)
        except (SyntaxError, ValueError) as exception:
            return [
                Label(
                    LabelName(f&#34;ast_construction:{type(exception).__name__}&#34;),
                    [Span(1, program.source.count(&#34;\n&#34;) + 1)],
                )
            ]
        # The next comment prevents a (wrong?) mypy error: &#34;AST&#34; has no attribute &#34;body&#34;
        if not tree.body:  # type: ignore
            return [Label(LabelName(&#34;ast_construction:EmptyProgramError&#34;), [Span(0, 0)])]
        self.flat_ast = flatten_ast(tree)

        # Search the flat AST for every feature which is specified by a regular expression.
        labels: LabelsSpans = defaultdict(list)
        for (label_prefix, finditer) in self.features.items():
            start = perf_counter()
            failed_match = True
            for match in finditer(self.flat_ast, overlapped=True):
                failed_match = False
                for (label_name, span) in get_bindings(label_prefix, match.capturesdict()):
                    try:  # Unless this binding (without its path) is scheduled for deletion...
                        program.deletion[label_name].remove(Span(span.start, span.end))  # (no path)
                    except (KeyError, ValueError):  # ... actually bind the name with the span.
                        labels[label_name].append(span)
            elapsed = perf_counter() - start
            self.times[label_prefix] += elapsed
            self.times[LabelName(&#34;TOTAL&#34;)] += elapsed
            if yield_failed_matches and failed_match:
                labels[label_prefix] = []

        # Update the matching features with those featured for addition.
        for (label_name, spans) in program.addition.items():
            labels[label_name].extend(spans)
            labels[label_name].sort()

        # Now, use the features found so far to derive all those specified by an SQL query.
        result = [Label(*item) for item in labels.items()]
        self.derived_labels_database.create(result)  # The search is seeded with the know features.
        for (label_name, query) in self.queries.items():
            # Try to derive, from the DB current state, some label names matching `label_name`.
            start = perf_counter()
            derived_labels = self.derived_labels_database.read(query)
            elapsed = perf_counter() - start
            self.times[label_name] += elapsed
            self.times[LabelName(&#34;TOTAL&#34;)] += elapsed
            # Suppress the labels scheduled for deletion
            labels.clear()  # reuse the dictionary associating each label name to its spans
            for label in derived_labels:
                for span in label.spans:
                    try:  # Unless this binding (without its path) is scheduled for deletion...
                        program.deletion[label.name].remove(Span(span.start, span.end))
                    except (KeyError, ValueError):  # ... actually bind the name with the span.
                        labels[label.name].append(span)
            derived_labels = [Label(*item) for item in labels.items()]
            if derived_labels:
                # Bingo! update the DB state and the result with the new labels.
                self.derived_labels_database.update(derived_labels)
                result.extend(derived_labels)
            elif yield_failed_matches:
                result.append(Label(label_name, []))
        # Empty the DB to make it ready for the next program.
        self.derived_labels_database.delete()

        return sorted(result)

    def print_performances(self):  # pragma: no cover
        result = sorted(self.times.items(), key=lambda item: item[1], reverse=True)
        print()
        print(&#34;Elapsed times by features (in seconds)&#34;)
        print(&#34;--------------------------------------&#34;)
        for (name, seconds) in result:
            print(f&#34;{seconds:8.4f}\t {name}&#34;)
        print()


if __name__ == &#34;__main__&#34;:
    # Take an individual source, print its features and write its flat AST.
    from .goodies import couple_to_string

    path = Path(&#34;sandbox/source.py&#34;)
    source = path.read_text().strip()
    if source.startswith(&#34;1   &#34;):
        source = regex.sub(r&#34;(?m)^.{1,4}&#34;, &#34;&#34;, source)
    for (i, line) in enumerate(source.split(&#34;\n&#34;), 1):
        print(f&#34;{i:&lt;4}{line}&#34;)
    program = Program(source=Source(source), labels=[], taxa=[], addition={}, deletion={})
    print()
    parse = ProgramParser()
    acc = []
    for (name, spans) in sorted(parse(program, yield_failed_matches=False)):
        spans_as_string = &#34;, &#34;.join(map(couple_to_string, spans))
        acc.append(f&#34;| `{name}` | {spans_as_string} |&#34;)
        # acc[-1] += &#34; %s |&#34; % &#34;, &#34;.join(f&#34;{span.path}&#34; for span in spans)
    print(&#34;\n&#34;.join(acc))
    Path(&#34;sandbox/flat_ast.txt&#34;).write_text(parse.flat_ast)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="paroxython.parse_program.find_all_features"><code class="name flex">
<span>def <span class="ident">find_all_features</span></span>(<span>specifications: str, <br>find_all: Callable = &lt;built-in method findall of regex&gt;<br>) ‑> Iterator[Tuple[LabelName, str, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate on all tuples defining an algorithmic feature in the given specification text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>specifications</code></strong> :&ensp;<code>str</code></dt>
<dd>Normally, the contents of <a href="https://github.com/laowantong/paroxython/blob/master/paroxython/resources/spec.md"><code>spec.md</code></a>.</dd>
<dt><strong><code>find_all</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>A function finding all feature-defining triples of the text.
<a href="developer_manual/index.html#default-argument-trick">Not to be explicitly provided.</a></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterator[Tuple[LabelName, str, str]]</code></dt>
<dd>
<p>An iterator yielding all matching triples of the form:</p>
<ol>
<li>label name pattern (e.g., <code>"try"</code> or <code>"try_raise|try_except"</code>),</li>
<li>language (currently, <code>"re"</code> or <code>"sql"</code>),</li>
<li>specification (respectively, a regular expression pattern or an <abbr title="Structured Query Language">SQL</abbr> query).</li>
</ol>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/parse_program.py#L24-L47" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def find_all_features(
    specifications: str,
    find_all: Callable = regex.compile(
        r&#34;(?ms)&#34;
        r&#34;^\#{4}\s+Feature\s+`(.+?)`&#34;  # capture the label&#39;s pattern
        r&#34;.+?\#{5}\s+Specification&#34;  # ensure the sequel is in the Specification section
        r&#34;.+?```(.*?)\n+(.*?)\n?```&#34;  # capture the language and the specification
    ).findall,
) -&gt; Iterator[Tuple[LabelName, str, str]]:
    return find_all(specifications)</code></pre>
</details>
</dd>
<dt id="paroxython.parse_program.pos_to_span"><code class="name flex">
<span>def <span class="ident">pos_to_span</span></span>(<span>pos: List[str]) ‑> Span</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a list of positions (as captured in a specification string) into a single span.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A non-empty list of strings of the form <code>f"{line_number}:{path}"</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Span</code></dt>
<dd>
<p>A named tuple consisting of:</p>
<ul>
<li><code>start</code>: the line number extracted from the first string;</li>
<li><code>end</code>: the line number extracted from the last string (the same as <code>start</code> if there
is only one string);</li>
<li><code>path</code>: the path extracted from the first string.</li>
</ul>
<p>Note that all other substrings, if any, are ignored.</p>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; pos_to_span([&quot;1:path_1&quot;])
Span(1, 1, &quot;path_1&quot;)
&gt;&gt;&gt; pos_to_span([&quot;1:path_1&quot;, &quot;2:path_2&quot;])
Span(1, 2, &quot;path_1&quot;)
&gt;&gt;&gt; pos_to_span([&quot;1:path_1&quot;, &quot;2:path_2&quot;, &quot;3:path_3&quot;, &quot;4:path_4&quot;])
Span(1, 4, &quot;path_1&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/parse_program.py#L50-L76" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def pos_to_span(pos: List[str]) -&gt; Span:
    (start, path) = pos[0].split(&#34;:&#34;)
    (end, _) = pos[-1].split(&#34;:&#34;)
    return Span(int(start), int(end), path)</code></pre>
</details>
</dd>
<dt id="paroxython.parse_program.get_bindings"><code class="name flex">
<span>def <span class="ident">get_bindings</span></span>(<span>label_prefix: LabelName, <br>captures: Dict[str, List[str]]<br>) ‑> Iterator[Tuple[LabelName, Span]]</span>
</code></dt>
<dd>
<div class="desc"><p>Analyze the matches of a feature, and bind the corresponding names and spans.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>label_prefix</code></strong> :&ensp;<code>LabelName</code></dt>
<dd>The name of a feature specified by a regular expression. Note that
such a name is literal: contrary to those defined by an <abbr title="Structured Query Language">SQL</abbr> query, they cannot include
the alternation meta-character (<code>"|"</code>).</dd>
<dt><strong><code>captures</code></strong> :&ensp;<code>Dict[str, List[str]]</code></dt>
<dd>A dictionary of the named groups and lists of all the
captures of those groups, as matched by the function <code>regex.finditer()</code>. Contains a
non-empty entry <code>"POS"</code> and, optionally, an entry <code>"SUFFIX"</code>. All other entries are
ignored.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Tuple[LabelName, Span]]</code></dt>
<dd>At least one binding between a label name and a span.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>The simplest cases happen when there is one or several <code>"POS"</code>, but no <code>"SUFFIX"</code>:</p>
<pre><code class="python-repl">&gt;&gt;&gt; get_bindings(&quot;null_operation&quot;, {&quot;POS&quot;: [&quot;4:1-3-1-5-1-&quot;]})
(&quot;null_operation&quot;, Span(start=4, end=4, path=&quot;1-3-1-5-1-&quot;))
&gt;&gt;&gt; get_bindings(&quot;while&quot;, {&quot;POS&quot;: [&quot;11:2-&quot;, &quot;16:2-1-4-2-1-2-&quot;]})
(&quot;while&quot;, Span(start=11, end=16, path=&quot;2-&quot;))
&gt;&gt;&gt; get_bindings(&quot;divisibility_test&quot;, {
...     &quot;POS&quot;: [&quot;15:3-5-1-2-1-0-&quot;],
...     &quot;SUFFIX&quot;: []
... })
(&quot;divisibility_test&quot;, Span(start=15, end=15, path=&quot;3-5-1-2-1-0-&quot;))
</code></pre>
<p>When there are as many <code>"POS"</code> than <code>"SUFFIX"</code>, they are binded pairwise. The
resulting spans cannot span multiple lines:</p>
<pre><code class="python-repl">&gt;&gt;&gt; get_bindings(&quot;literal&quot;, {
...     &quot;POS&quot;: [&quot;16:3-5-1-2-1-1-1-0-&quot;],
...     &quot;SUFFIX&quot;: [&quot;False&quot;],
... })
(&quot;literal:False&quot;, Span(start=16, end=16, path=&quot;3-5-1-2-1-1-1-0-&quot;))
&gt;&gt;&gt; get_bindings(&quot;if_test_atom&quot;, {
...     &quot;POS&quot;: [&quot;31:5-2-1-0-0-0-&quot;, &quot;31:5-2-1-0-0-2-1-1-&quot;, &quot;31:5-2-1-0-2-1-&quot;],
...     &quot;SUFFIX&quot;: [&quot;b&quot;, &quot;a&quot;, &quot;greatest&quot;],
... })
(&quot;if_test_atom:b&quot;, Span(start=31, end=31, path=&quot;5-2-1-0-0-0-&quot;))
(&quot;if_test_atom:a&quot;, Span(start=31, end=31, path=&quot;5-2-1-0-0-2-1-1-&quot;))
(&quot;if_test_atom:greatest&quot;, Span(start=31, end=31, path=&quot;5-2-1-0-2-1-&quot;))
</code></pre>
<p>In all other cases, <code>"POS"</code> is interpreted as delimiting only one occurrence (which can span
multiple lines), and associated repeatedly with the different suffixes:</p>
<pre><code class="python-repl">&gt;&gt;&gt; get_bindings(&quot;import_module&quot;, {&quot;POS&quot;: [&quot;1:1-&quot;], &quot;SUFFIX&quot;: [&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;]})
(&quot;import_module:m1&quot;, Span(start=1, end=1, path=&quot;1-&quot;))
(&quot;import_module:m2&quot;, Span(start=1, end=1, path=&quot;1-&quot;))
(&quot;import_module:m3&quot;, Span(start=1, end=1, path=&quot;1-&quot;))
&gt;&gt;&gt; get_bindings(&quot;function_decorator&quot;, {
...     &quot;POS&quot;: [&quot;1:1-&quot;, &quot;1:1-2-1-&quot;, &quot;2:1-2-2-&quot;, &quot;3:1-2-3-&quot;, &quot;5:1-5-1-&quot;],
...     &quot;SUFFIX&quot;: [&quot;bizz&quot;, &quot;foo&quot;, &quot;bar&quot;],
... })
(&quot;function_decorator:bizz&quot;, Span(start=1, end=5, path=&quot;1-&quot;)),
(&quot;function_decorator:foo&quot;, Span(start=1, end=5, path=&quot;1-&quot;)),
(&quot;function_decorator:bar&quot;, Span(start=1, end=5, path=&quot;1-&quot;)),
</code></pre>
<h2 id="warning">Warning</h2>
<p>Consider the problem of detecting the feature <code>for</code> in the following program:</p>
<pre><code class="python">for (i, j) in seq:
    pass
</code></pre>
<p>With such a multi-line feature, it is normally enough to capture <strong>two</strong> positions, namely
those of its start (1) and its end (2). However, in this case we want to suffix <code>for</code> with
the names of the <strong>two</strong> iterations variables (<code>for:i</code> and <code>for:j</code>). If we devise the
regular expression specification without special care:</p>
<pre><code class="re">        ^(.*)/_type=For
\n(?:\1.+\n)*?\1/_pos=(?P&lt;POS&gt;.+)
(
\n(?:\1.+\n)*?\1/target(/.+)?/id=(?P&lt;SUFFIX&gt;.+)
)+
\n(?:\1.+\n)* \1/.*/_pos=(?P&lt;POS&gt;.+)
</code></pre>
<p>&hellip; as many positions as there are suffixes will be passed to the present function:</p>
<pre><code class="python-repl">&gt;&gt;&gt; get_bindings(&quot;for&quot;, {'POS': ['1:1-', '2:1-2-1-'], 'SUFFIX': ['i', 'j']})
(&quot;for:i&quot;, Span(start=1, end=1, path=&quot;1-&quot;))
(&quot;for:j&quot;, Span(start=2, end=2, path=&quot;1-2-1-&quot;))
</code></pre>
<p>&hellip; which will result in two (wrong) bindings instead of one. The workaround implemented in
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/resources/spec.md#feature-for">spec.md</a> consists in capturing as
many supplementary positions as iteration variables:</p>
<pre><code class="re">        ^(.*)/_type=For
\n(?:\1.+\n)*?\1/_pos=(?P&lt;POS&gt;.+)
(
\n(?:\1.+\n)*?\1/(?P&lt;_1&gt;target(/.+)?)/_pos=(?P&lt;POS&gt;.+)
\n(?:\1.+\n)*?\1/(?P=_1)             /id=(?P&lt;SUFFIX&gt;.+)
)+
\n(?:\1.+\n)* \1/.*/_pos=(?P&lt;POS&gt;.+)
</code></pre>
<p>So, there are now two more positions in the captured dictionary. Since they are not at the
ends of the list, they are ignored by <code><a title="paroxython.parse_program.pos_to_span" href="#paroxython.parse_program.pos_to_span">pos_to_span()</a></code>, and the result is now correct:</p>
<pre><code class="python-repl">&gt;&gt;&gt; get_bindings(&quot;for&quot;, {
...     'POS': ['1:1-', '1:1-0-0-1-', '1:1-0-0-2-', '2:1-2-1-'],
...      '_1': ['target/elts/1', 'target/elts/2'],  # ignored at this level
...      'SUFFIX': ['i', 'j']
... })
(&quot;for:i&quot;, Span(start=1, end=2, path=&quot;1-&quot;))
(&quot;for:j&quot;, Span(start=1, end=2, path=&quot;1-&quot;))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/parse_program.py#L82-L210" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def get_bindings(
    label_prefix: LabelName, captures: Dict[str, List[str]]
) -&gt; Iterator[Tuple[LabelName, Span]]:
    if captures.get(&#34;SUFFIX&#34;):
        # There is a &#34;SUFFIX&#34; key and its value is not `[]`.
        if len(captures[&#34;POS&#34;]) == len(captures[&#34;SUFFIX&#34;]):
            # When there are as many matched positions as suffixes, associate them in parallel.
            for (suffix, pos) in zip(captures[&#34;SUFFIX&#34;], captures[&#34;POS&#34;]):
                yield (LabelName(f&#34;{label_prefix}:{suffix}&#34;), pos_to_span([pos]))
        else:
            # When there are more or less matched positions than suffixes, interpret the positions
            # as defining a unique span, and associate it with each suffix.
            span = pos_to_span(captures[&#34;POS&#34;])
            for suffix in captures[&#34;SUFFIX&#34;]:
                yield (LabelName(f&#34;{label_prefix}:{suffix}&#34;), span)
    else:
        # There is no &#34;SUFFIX&#34; key or its value is `[]`.
        yield (label_prefix, pos_to_span(captures[&#34;POS&#34;]))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="paroxython.parse_program.ProgramParser"><code class="flex name class">
<span>class <span class="ident">ProgramParser</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/parse_program.py#L213-L353" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">class ProgramParser:
    def __init__(self, spec_path: Path = DEFAULT_SPEC_PATH) -&gt; None:
        self.spec_path = spec_path
        text = self.spec_path.read_text()
        self.features: Dict[LabelName, regex.Pattern] = {}
        self.queries: Dict[LabelName, Query] = {}
        self.times: Dict[LabelName, float] = {LabelName(&#34;TOTAL&#34;): 0.0}
        for (label_name, language, specification) in find_all_features(text):
            if label_name in self.features:  # pragma: no cover
                print_fail(f&#34;Duplicated name &#39;{label_name}&#39;!&#34;)
            self.times[label_name] = 0.0
            if language == &#34;re&#34;:
                self.features[label_name] = regex.compile(f&#34;(?mx){specification}&#34;).finditer
            elif language == &#34;sql&#34;:
                self.queries[label_name] = Query(specification)
            elif specification.strip() != &#34;&#34;:  # pragma: no cover
                print_fail(f&#34;Unknow language &#39;{language}&#39; for &#39;{label_name}&#39;!&#34;)
        self.derived_labels_database = DerivedLabelsDatabase()

    def __call__(self, program: Program, yield_failed_matches: bool = False) -&gt; Labels:
        # If the program can be parsed and is nonempty, flatten its AST.
        try:
            tree = ast.parse(program.source)
        except (SyntaxError, ValueError) as exception:
            return [
                Label(
                    LabelName(f&#34;ast_construction:{type(exception).__name__}&#34;),
                    [Span(1, program.source.count(&#34;\n&#34;) + 1)],
                )
            ]
        # The next comment prevents a (wrong?) mypy error: &#34;AST&#34; has no attribute &#34;body&#34;
        if not tree.body:  # type: ignore
            return [Label(LabelName(&#34;ast_construction:EmptyProgramError&#34;), [Span(0, 0)])]
        self.flat_ast = flatten_ast(tree)

        # Search the flat AST for every feature which is specified by a regular expression.
        labels: LabelsSpans = defaultdict(list)
        for (label_prefix, finditer) in self.features.items():
            start = perf_counter()
            failed_match = True
            for match in finditer(self.flat_ast, overlapped=True):
                failed_match = False
                for (label_name, span) in get_bindings(label_prefix, match.capturesdict()):
                    try:  # Unless this binding (without its path) is scheduled for deletion...
                        program.deletion[label_name].remove(Span(span.start, span.end))  # (no path)
                    except (KeyError, ValueError):  # ... actually bind the name with the span.
                        labels[label_name].append(span)
            elapsed = perf_counter() - start
            self.times[label_prefix] += elapsed
            self.times[LabelName(&#34;TOTAL&#34;)] += elapsed
            if yield_failed_matches and failed_match:
                labels[label_prefix] = []

        # Update the matching features with those featured for addition.
        for (label_name, spans) in program.addition.items():
            labels[label_name].extend(spans)
            labels[label_name].sort()

        # Now, use the features found so far to derive all those specified by an SQL query.
        result = [Label(*item) for item in labels.items()]
        self.derived_labels_database.create(result)  # The search is seeded with the know features.
        for (label_name, query) in self.queries.items():
            # Try to derive, from the DB current state, some label names matching `label_name`.
            start = perf_counter()
            derived_labels = self.derived_labels_database.read(query)
            elapsed = perf_counter() - start
            self.times[label_name] += elapsed
            self.times[LabelName(&#34;TOTAL&#34;)] += elapsed
            # Suppress the labels scheduled for deletion
            labels.clear()  # reuse the dictionary associating each label name to its spans
            for label in derived_labels:
                for span in label.spans:
                    try:  # Unless this binding (without its path) is scheduled for deletion...
                        program.deletion[label.name].remove(Span(span.start, span.end))
                    except (KeyError, ValueError):  # ... actually bind the name with the span.
                        labels[label.name].append(span)
            derived_labels = [Label(*item) for item in labels.items()]
            if derived_labels:
                # Bingo! update the DB state and the result with the new labels.
                self.derived_labels_database.update(derived_labels)
                result.extend(derived_labels)
            elif yield_failed_matches:
                result.append(Label(label_name, []))
        # Empty the DB to make it ready for the next program.
        self.derived_labels_database.delete()

        return sorted(result)

    def print_performances(self):  # pragma: no cover
        result = sorted(self.times.items(), key=lambda item: item[1], reverse=True)
        print()
        print(&#34;Elapsed times by features (in seconds)&#34;)
        print(&#34;--------------------------------------&#34;)
        for (name, seconds) in result:
            print(f&#34;{seconds:8.4f}\t {name}&#34;)
        print()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="paroxython.parse_program.ProgramParser.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, <br>spec_path: pathlib.Path = PosixPath('./paroxython/resources/spec.md')<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Collect the features specified at <code>spec_path</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spec_path</code></strong> :&ensp;<code>Path</code>, optional</dt>
<dd>The path of the specification file. Defaults to
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/resources/spec.md">spec.md</a>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Fail when a given feature appears multiple times in the specification file,
and when the language is not <code>"re"</code> or <code>"sql"</code>, and the specification is non-empty.</dd>
</dl>
<h2 id="description">Description</h2>
<p>Some features are searched for with a regular expression, some with an <abbr title="Structured Query Language">SQL</abbr> query.
Distribute them in their respective dictionary. Compile the regular expressions and
pre-bind the appropriate method. Create an instance of the database of derived labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/parse_program.py#L214-L245" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def __init__(self, spec_path: Path = DEFAULT_SPEC_PATH) -&gt; None:
    self.spec_path = spec_path
    text = self.spec_path.read_text()
    self.features: Dict[LabelName, regex.Pattern] = {}
    self.queries: Dict[LabelName, Query] = {}
    self.times: Dict[LabelName, float] = {LabelName(&#34;TOTAL&#34;): 0.0}
    for (label_name, language, specification) in find_all_features(text):
        if label_name in self.features:  # pragma: no cover
            print_fail(f&#34;Duplicated name &#39;{label_name}&#39;!&#34;)
        self.times[label_name] = 0.0
        if language == &#34;re&#34;:
            self.features[label_name] = regex.compile(f&#34;(?mx){specification}&#34;).finditer
        elif language == &#34;sql&#34;:
            self.queries[label_name] = Query(specification)
        elif specification.strip() != &#34;&#34;:  # pragma: no cover
            print_fail(f&#34;Unknow language &#39;{language}&#39; for &#39;{label_name}&#39;!&#34;)
    self.derived_labels_database = DerivedLabelsDatabase()</code></pre>
</details>
</dd>
<dt id="paroxython.parse_program.ProgramParser.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, <br>program: Program, <br>yield_failed_matches: bool = False<br>) ‑> List[Label]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a given program and return its labels with their spans.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>program</code></strong> :&ensp;<code>Program</code></dt>
<dd>A <code>Program</code> object, with its fields <code>source</code>, <code>addition</code> and
<code>deletion</code> populated.</dd>
<dt><strong><code>yield_failed_matches</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, add to the returned labels those
which have not been found in the program. Each one is associated with an empty
list of spans. For testing purposes only. Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Labels</code></dt>
<dd>A sorted list of labels, associating each label name with its spans.</dd>
</dl>
<h2 id="description">Description</h2>
<ol>
<li>Parse the given program. If this fails or the resulting <abbr title="Abstract Syntax Tree">AST</abbr> is empty, return a list
consisting in a single label, <code>"ast_construction:"</code>, followed by the error name.
Otherwise, flatten the <abbr title="Abstract Syntax Tree">AST</abbr>.</li>
<li>Search it for every feature which is specified by a regular expression. Take care to
avoid adding those features which are scheduled for deletion at the same span.</li>
<li>Update the matching features with those featured for addition.</li>
<li>Use the features found so far to derive (directly and indirectly) all those specified
by an <abbr title="Structured Query Language">SQL</abbr> query.</li>
<li>Return the found features.</li>
</ol>
<h2 id="note">Note</h2>
<p>The computation of the derived features is done in a single pass, which require them to
be in a correct dependency order. This order is checked by <code>helpers/reformat_spec.py</code>,
which is executed each time the tests are launched.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/parse_program.py#L247-L343" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def __call__(self, program: Program, yield_failed_matches: bool = False) -&gt; Labels:
    # If the program can be parsed and is nonempty, flatten its AST.
    try:
        tree = ast.parse(program.source)
    except (SyntaxError, ValueError) as exception:
        return [
            Label(
                LabelName(f&#34;ast_construction:{type(exception).__name__}&#34;),
                [Span(1, program.source.count(&#34;\n&#34;) + 1)],
            )
        ]
    # The next comment prevents a (wrong?) mypy error: &#34;AST&#34; has no attribute &#34;body&#34;
    if not tree.body:  # type: ignore
        return [Label(LabelName(&#34;ast_construction:EmptyProgramError&#34;), [Span(0, 0)])]
    self.flat_ast = flatten_ast(tree)

    # Search the flat AST for every feature which is specified by a regular expression.
    labels: LabelsSpans = defaultdict(list)
    for (label_prefix, finditer) in self.features.items():
        start = perf_counter()
        failed_match = True
        for match in finditer(self.flat_ast, overlapped=True):
            failed_match = False
            for (label_name, span) in get_bindings(label_prefix, match.capturesdict()):
                try:  # Unless this binding (without its path) is scheduled for deletion...
                    program.deletion[label_name].remove(Span(span.start, span.end))  # (no path)
                except (KeyError, ValueError):  # ... actually bind the name with the span.
                    labels[label_name].append(span)
        elapsed = perf_counter() - start
        self.times[label_prefix] += elapsed
        self.times[LabelName(&#34;TOTAL&#34;)] += elapsed
        if yield_failed_matches and failed_match:
            labels[label_prefix] = []

    # Update the matching features with those featured for addition.
    for (label_name, spans) in program.addition.items():
        labels[label_name].extend(spans)
        labels[label_name].sort()

    # Now, use the features found so far to derive all those specified by an SQL query.
    result = [Label(*item) for item in labels.items()]
    self.derived_labels_database.create(result)  # The search is seeded with the know features.
    for (label_name, query) in self.queries.items():
        # Try to derive, from the DB current state, some label names matching `label_name`.
        start = perf_counter()
        derived_labels = self.derived_labels_database.read(query)
        elapsed = perf_counter() - start
        self.times[label_name] += elapsed
        self.times[LabelName(&#34;TOTAL&#34;)] += elapsed
        # Suppress the labels scheduled for deletion
        labels.clear()  # reuse the dictionary associating each label name to its spans
        for label in derived_labels:
            for span in label.spans:
                try:  # Unless this binding (without its path) is scheduled for deletion...
                    program.deletion[label.name].remove(Span(span.start, span.end))
                except (KeyError, ValueError):  # ... actually bind the name with the span.
                    labels[label.name].append(span)
        derived_labels = [Label(*item) for item in labels.items()]
        if derived_labels:
            # Bingo! update the DB state and the result with the new labels.
            self.derived_labels_database.update(derived_labels)
            result.extend(derived_labels)
        elif yield_failed_matches:
            result.append(Label(label_name, []))
    # Empty the DB to make it ready for the next program.
    self.derived_labels_database.delete()

    return sorted(result)</code></pre>
</details>
</dd>
<dt id="paroxython.parse_program.ProgramParser.print_performances"><code class="name flex">
<span>def <span class="ident">print_performances</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a <abbr title="Tab Separated Values">TSV</abbr> report of elapsed times by features, sorted by decreasing time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/parse_program.py#L345-L353" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def print_performances(self):  # pragma: no cover
    result = sorted(self.times.items(), key=lambda item: item[1], reverse=True)
    print()
    print(&#34;Elapsed times by features (in seconds)&#34;)
    print(&#34;--------------------------------------&#34;)
    for (name, seconds) in result:
        print(f&#34;{seconds:8.4f}\t {name}&#34;)
    print()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Paroxython Home" href="index.html">
<img src="https://laowantong.github.io/paroxython/resources/logo.png" alt="Paroxython logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="paroxython" href="index.html">paroxython</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="paroxython.parse_program.find_all_features" href="#paroxython.parse_program.find_all_features">find_all_features</a></code></li>
<li><code><a title="paroxython.parse_program.pos_to_span" href="#paroxython.parse_program.pos_to_span">pos_to_span</a></code></li>
<li><code><a title="paroxython.parse_program.get_bindings" href="#paroxython.parse_program.get_bindings">get_bindings</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="paroxython.parse_program.ProgramParser" href="#paroxython.parse_program.ProgramParser">ProgramParser</a></code></h4>
<ul class="">
<li><code><a title="paroxython.parse_program.ProgramParser.__init__" href="#paroxython.parse_program.ProgramParser.__init__">__init__</a></code></li>
<li><code><a title="paroxython.parse_program.ProgramParser.__call__" href="#paroxython.parse_program.ProgramParser.__call__">__call__</a></code></li>
<li><code><a title="paroxython.parse_program.ProgramParser.print_performances" href="#paroxython.parse_program.ProgramParser.print_performances">print_performances</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>