<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>paroxython.make_db API documentation</title>
<meta name="description" content="Collect all infos pertaining to the programs, labels and taxa into a so-called tag database." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<a href="https://github.com/laowantong/paroxython"><img style="position: absolute; top: 0; right: 0; border: 0; width: 150px; height: 150px" src="https://laowantong.github.io/paroxython/resources/source_on_github.png" alt="Source on GitHub"></a>
<style>.homelink{display:block}.homelink:hover{color:inherit}.homelink img{margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://laowantong.github.io/paroxython/make_db.html">
<link rel="icon" href="https://laowantong.github.io/paroxython/resources/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>paroxython.make_db</code></h1>
</header>
<section id="section-intro">
<p>Collect all infos pertaining to the programs, labels and taxa into a so-called tag database.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L0-L453" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">import json
import sqlite3
from bisect import insort
from collections import defaultdict
from datetime import datetime
from functools import lru_cache
from pathlib import Path
from typing import Callable, List, Optional, Tuple, Dict

import regex  # type: ignore

from .goodies import add_line_numbers
from .label_programs import labelled_programs, iterate_and_print_programs
from .map_taxonomy import Taxonomy
from .user_types import (
    LabelInfos,
    Labels,
    LabelsPoorSpans,
    ProgramInfos,
    ProgramPath,
    ProgramPathSet,
    Programs,
    ProgramToPrograms,
    TaxonInfos,
    Taxa,
    TaxaPoorSpans,
)

__pdoc__ = {
    &#34;TagDatabase&#34;: &#34;&#34;,
    &#34;TagDatabase.__init__&#34;: True,
}


class TagDatabase:
    def __init__(self, directory: Path, ignore_timestamps: bool = False, **kwargs) -&gt; None:
        self.directory = directory
        programs: Programs = labelled_programs(directory, **kwargs)
        self.labels = collect_labels(programs)

        map_labels_on_taxa(programs, Taxonomy(**kwargs))
        self.taxa = collect_taxa(programs)

        importations = compute_direct_importations(programs)
        self.importations = complete_and_collect_importations(importations)
        self.exportations = compute_and_collect_exportations(programs, self.importations)

        get_timestamp = lambda path: str(datetime.fromtimestamp(path.stat().st_mtime))
        if ignore_timestamps:
            get_timestamp = lambda path: &#34;&#34;
        self.programs_infos: ProgramInfos = {}
        for program in programs:
            self.programs_infos[program.path] = {
                &#34;timestamp&#34;: get_timestamp(directory / program.path),
                &#34;source&#34;: program.source,
                &#34;labels&#34;: prepared_labels(program.labels),
                &#34;taxa&#34;: prepared_taxa(program.taxa),
            }

    def get_json(self) -&gt; str:
        data = {
            &#34;programs&#34;: self.programs_infos,
            &#34;labels&#34;: dict(sorted(self.labels.items())),
            &#34;taxa&#34;: dict(sorted(self.taxa.items())),
            &#34;importations&#34;: dict(self.importations.items()),
            &#34;exportations&#34;: dict(self.exportations.items()),
        }
        text = json.dumps(data, indent=2) + &#34;\n&#34;
        text = regex.sub(r&#34;\s*\[\s+(\d+),\s+(\d+)\s+\](,?)\s+&#34;, r&#34;[\1,\2]\3&#34;, text)
        return text

    def write_json(self, db_path: Optional[Path] = None) -&gt; None:
        db_path = db_path or self.directory.parent / f&#34;{self.directory.name}_db.json&#34;
        print(f&#34;Writing {db_path}.&#34;)
        db_path.write_text(self.get_json())

    def write_sqlite(self, db_path: Optional[Path] = None) -&gt; None:
        db_path = db_path or self.directory.parent / f&#34;{self.directory.name}_db.sqlite&#34;
        print(f&#34;Writing {db_path}.&#34;)
        program_rows: List[Tuple] = []
        label_rows: List[Tuple] = []
        taxon_rows: List[Tuple] = []
        for (path, info) in self.programs_infos.items():
            source = f&#34;{path}\n\n&#34; + add_line_numbers(info[&#34;source&#34;])
            program_rows.append((path, info[&#34;timestamp&#34;], source))
            for (label_name, spans) in info[&#34;labels&#34;].items():
                (prefix, _, suffix) = label_name.partition(&#34;:&#34;)
                for span in spans:
                    label_rows.append(
                        (
                            label_name,
                            prefix,
                            suffix,
                            &#34;-&#34;.join(map(str, span)) if span[0] != span[1] else str(span[0]),
                            span[0],
                            span[1],
                            path,
                        )
                    )
            for (taxon_name, spans) in info[&#34;taxa&#34;].items():
                for span in spans:
                    taxon_rows.append(
                        (
                            taxon_name,
                            &#34;-&#34;.join(map(str, span)) if span[0] != span[1] else str(span[0]),
                            span[0],
                            span[1],
                            path,
                        )
                    )

        if db_path.exists():  # pragma: no cover / Python 3.8: use missing_ok=True parameter
            db_path.unlink()
        connexion = sqlite3.connect(str(db_path))  # str() for Python 3.6 compatibility
        c = connexion.cursor()

        fill = lambda columns: &#34;,&#34;.join(&#34;?&#34; * len(columns))
        program_columns = (
            &#34;program TEXT PRIMARY KEY&#34;,
            &#34;timestamp TEXT&#34;,
            &#34;source TEXT&#34;,
        )
        c.execute(f&#34;CREATE TABLE program ({&#39;,&#39;.join(program_columns)})&#34;)
        c.executemany(f&#34;INSERT INTO program VALUES ({fill(program_columns)})&#34;, program_rows)

        label_columns = (
            # use rowid as primary key
            &#34;label TEXT&#34;,
            &#34;label_prefix TEXT&#34;,
            &#34;label_suffix TEXT&#34;,
            &#34;span TEXT&#34;,
            &#34;span_start INTEGER&#34;,
            &#34;span_end INTEGER&#34;,
            &#34;program TEXT&#34;,
        )
        c.execute(
            f&#34;CREATE TABLE label ({&#39;,&#39;.join(label_columns)},&#34;
            &#34;FOREIGN KEY (program) REFERENCES program (program))&#34;
        )
        c.executemany(f&#34;INSERT INTO label VALUES ({fill(label_columns)})&#34;, label_rows)

        taxon_columns = (
            # use rowid as primary key
            &#34;taxon TEXT&#34;,
            &#34;span TEXT&#34;,
            &#34;span_start INTEGER&#34;,
            &#34;span_end INTEGER&#34;,
            &#34;program TEXT&#34;,
        )
        c.execute(
            f&#34;CREATE TABLE taxon ({&#39;,&#39;.join(taxon_columns)},&#34;
            &#34;FOREIGN KEY (program) REFERENCES program (program))&#34;
        )
        c.executemany(f&#34;INSERT INTO taxon VALUES ({fill(taxon_columns)})&#34;, taxon_rows)

        connexion.commit()
        connexion.close()


def collect_labels(programs: Programs) -&gt; LabelInfos:
    result: LabelInfos = defaultdict(list)
    for program in programs:
        for label in program.labels:
            result[label.name].append(program.path)
    return result


def map_labels_on_taxa(programs: Programs, taxonomy: Taxonomy) -&gt; None:
    print(f&#34;Mapping taxonomy on {len(programs)} programs.&#34;)
    for program in iterate_and_print_programs(programs):
        program.taxa[:] = taxonomy.to_taxa(program.labels)
        # `program` being a tuple, modifying its fields can only be done in place.


def collect_taxa(programs: Programs) -&gt; TaxonInfos:
    result: TaxonInfos = defaultdict(list)
    for program in programs:
        for taxon in program.taxa:
            result[taxon.name].append(program.path)
    return result


def compute_direct_importations(
    programs: Programs, match_import: Callable = regex.compile(r&#34;import_internally:([^:]+)&#34;).match
) -&gt; ProgramToPrograms:
    importations: Dict = {program.path: set() for program in programs}
    for program in programs:
        for label in program.labels:
            match = match_import(label.name)
            if match:  # Python 3.8: use assignement-expression
                importations[program.path].add(f&#34;{match[1]}.py&#34;)
    return importations


def complete_and_collect_importations(importations: ProgramToPrograms) -&gt; ProgramToPrograms:
    @lru_cache(maxsize=None)
    def complete_internal_imports(program_path: ProgramPath) -&gt; ProgramPathSet:
        result: ProgramPathSet = set(importations.get(program_path, []))
        for imported in list(result):  # traverse a copy
            result.update(complete_internal_imports(imported))
        return result

    completed_importations: ProgramToPrograms = {}
    for program_path in list(importations.keys()):
        completed_importations[program_path] = sorted(complete_internal_imports(program_path))
    return completed_importations


def compute_and_collect_exportations(
    programs: Programs, importations: ProgramToPrograms
) -&gt; ProgramToPrograms:
    exportations: ProgramToPrograms = {program.path: [] for program in programs}
    for (importing_path, imported_paths) in importations.items():
        for imported_path in imported_paths:
            if importing_path not in exportations[imported_path]:
                insort(exportations[imported_path], importing_path)
    return exportations


def prepared_labels(labels: Labels) -&gt; LabelsPoorSpans:
    result: LabelsPoorSpans = {}
    for (label_name, spans) in labels:
        result[label_name] = [(span.start, span.end) for span in sorted(set(spans))]
    return result


def prepared_taxa(taxa: Taxa) -&gt; TaxaPoorSpans:
    result: TaxaPoorSpans = {}
    for (taxon_name, spans) in taxa:
        result[taxon_name] = [(span.start, span.end) for span in sorted(spans)]
    return result


if __name__ == &#34;__main__&#34;:
    # fmt:off
    directories = [
        # &#34;examples/simple/programs&#34;,
        # &#34;../algo/programs&#34;,
        &#34;../Python&#34;,
    ]
    # fmt:on
    print()
    for directory in directories:
        db = TagDatabase(Path(directory), ignore_timestamps=True)
        db.write_json()
        db.write_sqlite()
    print()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="paroxython.make_db.collect_labels"><code class="name flex">
<span>def <span class="ident">collect_labels</span></span>(<span>programs: List[Program]) ‑> Dict[LabelName, List[ProgramPath]]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate through the given programs to collect all their labels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>Programs</code></dt>
<dd>A list of <code>Program</code> objects, with their <code>name</code> and <code>labels</code> fields
already populated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LabelInfos</code></dt>
<dd>A dictionary mapping each label name to the names of the programs featuring it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L245-L259" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def collect_labels(programs: Programs) -&gt; LabelInfos:
    result: LabelInfos = defaultdict(list)
    for program in programs:
        for label in program.labels:
            result[label.name].append(program.path)
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.map_labels_on_taxa"><code class="name flex">
<span>def <span class="ident">map_labels_on_taxa</span></span>(<span>programs: List[Program], <br>taxonomy: <a title="paroxython.map_taxonomy.Taxonomy" href="map_taxonomy.html#paroxython.map_taxonomy.Taxonomy">Taxonomy</a><br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Populate the <code>taxa</code> fields of the given <code>programs</code> with the translations of their labels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>Programs</code></dt>
<dd>A list of <code>Program</code> objects with their <code>labels</code> field populated.</dd>
<dt><strong><code>taxonomy</code></strong> :&ensp;<code>Taxonomy</code></dt>
<dd>A “translator” of label names into taxon names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L262-L271" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def map_labels_on_taxa(programs: Programs, taxonomy: Taxonomy) -&gt; None:
    print(f&#34;Mapping taxonomy on {len(programs)} programs.&#34;)
    for program in iterate_and_print_programs(programs):
        program.taxa[:] = taxonomy.to_taxa(program.labels)</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.collect_taxa"><code class="name flex">
<span>def <span class="ident">collect_taxa</span></span>(<span>programs: List[Program]) ‑> Dict[TaxonName, List[ProgramPath]]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate through the given programs to collect all their taxa.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>Programs</code></dt>
<dd>A list of <code>Program</code> objects, with their <code>name</code> and <code>taxa</code> fields
already populated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TaxonInfos</code></dt>
<dd>A dictionary mapping each taxon name to the names of the programs featuring it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L275-L289" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def collect_taxa(programs: Programs) -&gt; TaxonInfos:
    result: TaxonInfos = defaultdict(list)
    for program in programs:
        for taxon in program.taxa:
            result[taxon.name].append(program.path)
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.compute_direct_importations"><code class="name flex">
<span>def <span class="ident">compute_direct_importations</span></span>(<span>programs: List[Program], <br>match_import: Callable = &lt;built-in method match of regex&gt;<br>) ‑> Dict[ProgramPath, List[ProgramPath]]</span>
</code></dt>
<dd>
<div class="desc"><p>Associate each given labelled program to the set of its direct internal imports.</p>
<h2 id="description">Description</h2>
<p>Iterate through the programs, retrieve their labels starting with <code>"import_internally"</code>
and collect the names of the involved programs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>Programs</code></dt>
<dd>A list of labelled <code>Program</code> objects.</dd>
<dt><strong><code>match_import</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>A function taking a label name and, in
the case it starts with <code>"import_internally:"</code>, returns a match object whose
first group is the name of the imported program.
<a href="developer_manual/index.html#default-argument-trick">Not to be explicitly provided.</a></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgramToPrograms</code></dt>
<dd>A dictionary mapping every program path to the list of the paths of
the internal programs it imports directly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L292-L318" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def compute_direct_importations(
    programs: Programs, match_import: Callable = regex.compile(r&#34;import_internally:([^:]+)&#34;).match
) -&gt; ProgramToPrograms:
    importations: Dict = {program.path: set() for program in programs}
    for program in programs:
        for label in program.labels:
            match = match_import(label.name)
            if match:  # Python 3.8: use assignement-expression
                importations[program.path].add(f&#34;{match[1]}.py&#34;)
    return importations</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.complete_and_collect_importations"><code class="name flex">
<span>def <span class="ident">complete_and_collect_importations</span></span>(<span>importations: Dict[ProgramPath, List[ProgramPath]]<br>) ‑> Dict[ProgramPath, List[ProgramPath]]</span>
</code></dt>
<dd>
<div class="desc"><p>Complete the direct internal imports with indirect ones.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>importations</code></strong> :&ensp;<code>ProgramToPrograms</code></dt>
<dd>A dictionary mapping every program path to the list
of the paths of the internal programs it imports directly.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgramToPrograms</code></dt>
<dd>A dictionary mapping every program path to the sorted list of the
paths of the internal programs it imports either directly or indirectly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L321-L343" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def complete_and_collect_importations(importations: ProgramToPrograms) -&gt; ProgramToPrograms:
    @lru_cache(maxsize=None)
    def complete_internal_imports(program_path: ProgramPath) -&gt; ProgramPathSet:
        result: ProgramPathSet = set(importations.get(program_path, []))
        for imported in list(result):  # traverse a copy
            result.update(complete_internal_imports(imported))
        return result

    completed_importations: ProgramToPrograms = {}
    for program_path in list(importations.keys()):
        completed_importations[program_path] = sorted(complete_internal_imports(program_path))
    return completed_importations</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.compute_and_collect_exportations"><code class="name flex">
<span>def <span class="ident">compute_and_collect_exportations</span></span>(<span>programs: List[Program], <br>importations: Dict[ProgramPath, List[ProgramPath]]<br>) ‑> Dict[ProgramPath, List[ProgramPath]]</span>
</code></dt>
<dd>
<div class="desc"><p>Invert <code>importations</code> to construct <code>exportations</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>Programs</code></dt>
<dd>A list of named <code>Program</code> objects.</dd>
<dt><strong><code>importations</code></strong> :&ensp;<code>ProgramToPrograms</code></dt>
<dd>A dictionary mapping every program path to the list of
the paths of the internal programs it imports either directly or indirectly.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgramToPrograms</code></dt>
<dd>A dictionary mapping every program path to the sorted list of the paths
of the internal programs it is imported by, either directly or indirectly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L346-L365" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def compute_and_collect_exportations(
    programs: Programs, importations: ProgramToPrograms
) -&gt; ProgramToPrograms:
    exportations: ProgramToPrograms = {program.path: [] for program in programs}
    for (importing_path, imported_paths) in importations.items():
        for imported_path in imported_paths:
            if importing_path not in exportations[imported_path]:
                insort(exportations[imported_path], importing_path)
    return exportations</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.prepared_labels"><code class="name flex">
<span>def <span class="ident">prepared_labels</span></span>(<span>labels: List[Label]) ‑> Dict[LabelName, List[Tuple[int, int]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the labels for serialization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>labels</code></strong> :&ensp;<code>Labels</code></dt>
<dd>The list of labels to be serialized. Each label consists in a name and a
<strong>list</strong> of spans. Each span is a tuple starting by the actual range of line numbers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LabelPoorSpans:
A dictionary mapping the label names with the list of their spans, transformed into
simple couples of integers.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; prepared_labels([
...     (&quot;name_1&quot;, [
...             Span(start=1, end=2, path=&quot;foo&quot;),
...             Span(start=1, end=2, path=&quot;foo&quot;),  # note the duplicate
...             Span(start=1, end=2, path=&quot;bar&quot;),  # note the difference
...         ]),
...     (&quot;name_2&quot;, [
...             Span(start=2, end=4, path=&quot;fizz&quot;),
...             Span(start=6, end=7, path=&quot;buzz&quot;),
...         ]),
...     (&quot;name_3&quot;, [Span(start=5, end=5, path=&quot;foobar&quot;)]),
... ])
{
    &quot;name_1&quot;: [(1, 2), (1, 2)],  # deduplicated
    &quot;name_2&quot;: [(2, 4), (6, 7)],
    &quot;name_3&quot;: [(5, 5)],
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L368-L402" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def prepared_labels(labels: Labels) -&gt; LabelsPoorSpans:
    result: LabelsPoorSpans = {}
    for (label_name, spans) in labels:
        result[label_name] = [(span.start, span.end) for span in sorted(set(spans))]
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.prepared_taxa"><code class="name flex">
<span>def <span class="ident">prepared_taxa</span></span>(<span>taxa: List[Taxon]) ‑> Dict[TaxonName, List[Tuple[int, int]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the taxa for serialization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>taxa</code></strong> :&ensp;<code>Taxa</code></dt>
<dd>The list of taxa to be serialized. Each taxon consists in a name and a
<strong>bag</strong> of spans. Each span is a tuple starting by the actual range of line numbers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>TaxonPoorSpans:
A dictionary mapping the taxon names with the list of their spans, transformed into
simple couples of integers.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; prepared_taxa([
...     (&quot;name_1&quot;, Counter({
...             Span(start=1, end=2, path=&quot;foo&quot;): 2,  # note the duplicate
...             Span(start=1, end=2, path=&quot;bar&quot;): 1,
...         })),
...     (&quot;name_2&quot;, Counter({
...             Span(start=2, end=4, path=&quot;fizz&quot;): 1,
...             Span(start=6, end=7, path=&quot;buzz&quot;): 1,
...         })),
...     (&quot;name_3&quot;, Counter({Span(start=5, end=5, path=&quot;foobar&quot;): 1}))
... ])
{
    &quot;name_1&quot;: [(1, 2), (1, 2)],  # deduplicated
    &quot;name_2&quot;: [(2, 4), (6, 7)],
    &quot;name_3&quot;: [(5, 5)],
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L405-L438" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def prepared_taxa(taxa: Taxa) -&gt; TaxaPoorSpans:
    result: TaxaPoorSpans = {}
    for (taxon_name, spans) in taxa:
        result[taxon_name] = [(span.start, span.end) for span in sorted(spans)]
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="paroxython.make_db.TagDatabase"><code class="flex name class">
<span>class <span class="ident">TagDatabase</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L37-L242" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">class TagDatabase:
    def __init__(self, directory: Path, ignore_timestamps: bool = False, **kwargs) -&gt; None:
        self.directory = directory
        programs: Programs = labelled_programs(directory, **kwargs)
        self.labels = collect_labels(programs)

        map_labels_on_taxa(programs, Taxonomy(**kwargs))
        self.taxa = collect_taxa(programs)

        importations = compute_direct_importations(programs)
        self.importations = complete_and_collect_importations(importations)
        self.exportations = compute_and_collect_exportations(programs, self.importations)

        get_timestamp = lambda path: str(datetime.fromtimestamp(path.stat().st_mtime))
        if ignore_timestamps:
            get_timestamp = lambda path: &#34;&#34;
        self.programs_infos: ProgramInfos = {}
        for program in programs:
            self.programs_infos[program.path] = {
                &#34;timestamp&#34;: get_timestamp(directory / program.path),
                &#34;source&#34;: program.source,
                &#34;labels&#34;: prepared_labels(program.labels),
                &#34;taxa&#34;: prepared_taxa(program.taxa),
            }

    def get_json(self) -&gt; str:
        data = {
            &#34;programs&#34;: self.programs_infos,
            &#34;labels&#34;: dict(sorted(self.labels.items())),
            &#34;taxa&#34;: dict(sorted(self.taxa.items())),
            &#34;importations&#34;: dict(self.importations.items()),
            &#34;exportations&#34;: dict(self.exportations.items()),
        }
        text = json.dumps(data, indent=2) + &#34;\n&#34;
        text = regex.sub(r&#34;\s*\[\s+(\d+),\s+(\d+)\s+\](,?)\s+&#34;, r&#34;[\1,\2]\3&#34;, text)
        return text

    def write_json(self, db_path: Optional[Path] = None) -&gt; None:
        db_path = db_path or self.directory.parent / f&#34;{self.directory.name}_db.json&#34;
        print(f&#34;Writing {db_path}.&#34;)
        db_path.write_text(self.get_json())

    def write_sqlite(self, db_path: Optional[Path] = None) -&gt; None:
        db_path = db_path or self.directory.parent / f&#34;{self.directory.name}_db.sqlite&#34;
        print(f&#34;Writing {db_path}.&#34;)
        program_rows: List[Tuple] = []
        label_rows: List[Tuple] = []
        taxon_rows: List[Tuple] = []
        for (path, info) in self.programs_infos.items():
            source = f&#34;{path}\n\n&#34; + add_line_numbers(info[&#34;source&#34;])
            program_rows.append((path, info[&#34;timestamp&#34;], source))
            for (label_name, spans) in info[&#34;labels&#34;].items():
                (prefix, _, suffix) = label_name.partition(&#34;:&#34;)
                for span in spans:
                    label_rows.append(
                        (
                            label_name,
                            prefix,
                            suffix,
                            &#34;-&#34;.join(map(str, span)) if span[0] != span[1] else str(span[0]),
                            span[0],
                            span[1],
                            path,
                        )
                    )
            for (taxon_name, spans) in info[&#34;taxa&#34;].items():
                for span in spans:
                    taxon_rows.append(
                        (
                            taxon_name,
                            &#34;-&#34;.join(map(str, span)) if span[0] != span[1] else str(span[0]),
                            span[0],
                            span[1],
                            path,
                        )
                    )

        if db_path.exists():  # pragma: no cover / Python 3.8: use missing_ok=True parameter
            db_path.unlink()
        connexion = sqlite3.connect(str(db_path))  # str() for Python 3.6 compatibility
        c = connexion.cursor()

        fill = lambda columns: &#34;,&#34;.join(&#34;?&#34; * len(columns))
        program_columns = (
            &#34;program TEXT PRIMARY KEY&#34;,
            &#34;timestamp TEXT&#34;,
            &#34;source TEXT&#34;,
        )
        c.execute(f&#34;CREATE TABLE program ({&#39;,&#39;.join(program_columns)})&#34;)
        c.executemany(f&#34;INSERT INTO program VALUES ({fill(program_columns)})&#34;, program_rows)

        label_columns = (
            # use rowid as primary key
            &#34;label TEXT&#34;,
            &#34;label_prefix TEXT&#34;,
            &#34;label_suffix TEXT&#34;,
            &#34;span TEXT&#34;,
            &#34;span_start INTEGER&#34;,
            &#34;span_end INTEGER&#34;,
            &#34;program TEXT&#34;,
        )
        c.execute(
            f&#34;CREATE TABLE label ({&#39;,&#39;.join(label_columns)},&#34;
            &#34;FOREIGN KEY (program) REFERENCES program (program))&#34;
        )
        c.executemany(f&#34;INSERT INTO label VALUES ({fill(label_columns)})&#34;, label_rows)

        taxon_columns = (
            # use rowid as primary key
            &#34;taxon TEXT&#34;,
            &#34;span TEXT&#34;,
            &#34;span_start INTEGER&#34;,
            &#34;span_end INTEGER&#34;,
            &#34;program TEXT&#34;,
        )
        c.execute(
            f&#34;CREATE TABLE taxon ({&#39;,&#39;.join(taxon_columns)},&#34;
            &#34;FOREIGN KEY (program) REFERENCES program (program))&#34;
        )
        c.executemany(f&#34;INSERT INTO taxon VALUES ({fill(taxon_columns)})&#34;, taxon_rows)

        connexion.commit()
        connexion.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="paroxython.make_db.TagDatabase.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, <br>directory: pathlib.Path, <br>ignore_timestamps: bool = False, <br>**kwargs<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Construct and populate the complete database of program features.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>Path</code></dt>
<dd>The directory to walk (by default, recursively), containing the
Python programs of interest.</dd>
<dt><strong><code>ignore_timestamps</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Don't store the last modification dates of these
programms. Since the database snapshots generated by our tests are placed under
version control, this prevents Git from tracking irrelevant differences. Defaults
to <code>False</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>May include the keyword arguments:</p>
<ul>
<li><code>print_performances</code>, transmitted to
<code><a title="paroxython.label_programs.labelled_programs" href="label_programs.html#paroxython.label_programs.labelled_programs">labelled_programs()</a></code>;</li>
<li><code>cleanup_strategy</code>, <code>skip_pattern</code>, <code>glob_pattern</code>, transmitted to
<code><a title="paroxython.list_programs.list_programs" href="list_programs.html#paroxython.list_programs.list_programs">list_programs()</a></code> through
<code><a title="paroxython.label_programs.labelled_programs" href="label_programs.html#paroxython.label_programs.labelled_programs">labelled_programs()</a></code>;</li>
<li><code>taxonomy_path</code>, transmitted to <code><a title="paroxython.map_taxonomy.Taxonomy" href="map_taxonomy.html#paroxython.map_taxonomy.Taxonomy">Taxonomy</a></code>.</li>
</ul>
</dd>
</dl>
<h2 id="description">Description</h2>
<ol>
<li>Create a list <code>programs</code> of <code>Program</code> objects, labelled by
<code><a title="paroxython.label_programs.labelled_programs" href="label_programs.html#paroxython.label_programs.labelled_programs">labelled_programs()</a></code>.</li>
<li>Create a dictionary <code>self.labels</code> mapping each label name to the names of the
programs featuring it (<code><a title="paroxython.make_db.collect_labels" href="#paroxython.make_db.collect_labels">collect_labels()</a></code>).</li>
<li>Map the labels to taxa (<code><a title="paroxython.map_taxonomy.Taxonomy" href="map_taxonomy.html#paroxython.map_taxonomy.Taxonomy">Taxonomy</a></code>), and populate the field
<code>taxa</code> of <code>programs</code> (<code><a title="paroxython.make_db.map_labels_on_taxa" href="#paroxython.make_db.map_labels_on_taxa">map_labels_on_taxa()</a></code>).</li>
<li>Create a dictionary <code>self.taxa</code> mapping each taxon name to the names of the
programs featuring it (<code><a title="paroxython.make_db.collect_taxa" href="#paroxython.make_db.collect_taxa">collect_taxa()</a></code>).</li>
<li>Create a dictionary <code>self.importations</code> mapping each program path to the paths
of the programs importing it, both directly (<code><a title="paroxython.make_db.compute_direct_importations" href="#paroxython.make_db.compute_direct_importations">compute_direct_importations()</a></code>) and
indirectly (<code><a title="paroxython.make_db.complete_and_collect_importations" href="#paroxython.make_db.complete_and_collect_importations">complete_and_collect_importations()</a></code>).</li>
<li>Invert the previous dictionary to create a dictionary <code>self.exportations</code>
(<code><a title="paroxython.make_db.compute_and_collect_exportations" href="#paroxython.make_db.compute_and_collect_exportations">compute_and_collect_exportations()</a></code>).</li>
<li>Gather in <code>self.programs_infos</code> each program timestamp, source, labels and taxa as
a serialization-ready dictionary indexed by program paths.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L38-L96" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def __init__(self, directory: Path, ignore_timestamps: bool = False, **kwargs) -&gt; None:
    self.directory = directory
    programs: Programs = labelled_programs(directory, **kwargs)
    self.labels = collect_labels(programs)

    map_labels_on_taxa(programs, Taxonomy(**kwargs))
    self.taxa = collect_taxa(programs)

    importations = compute_direct_importations(programs)
    self.importations = complete_and_collect_importations(importations)
    self.exportations = compute_and_collect_exportations(programs, self.importations)

    get_timestamp = lambda path: str(datetime.fromtimestamp(path.stat().st_mtime))
    if ignore_timestamps:
        get_timestamp = lambda path: &#34;&#34;
    self.programs_infos: ProgramInfos = {}
    for program in programs:
        self.programs_infos[program.path] = {
            &#34;timestamp&#34;: get_timestamp(directory / program.path),
            &#34;source&#34;: program.source,
            &#34;labels&#34;: prepared_labels(program.labels),
            &#34;taxa&#34;: prepared_taxa(program.taxa),
        }</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.TagDatabase.get_json"><code class="name flex">
<span>def <span class="ident">get_json</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Dump the constructed <code><a title="paroxython.make_db.TagDatabase" href="#paroxython.make_db.TagDatabase">TagDatabase</a></code> object as a <abbr title="JavaScript Object Notation">JSON</abbr> string.</p>
<h2 id="description">Description</h2>
<p>Schema and purpose <a href="user_manual/index.html#the-json-database">in the user manual</a>.</p>
<h2 id="example">Example</h2>
<p>See the <a href="https://github.com/laowantong/paroxython/blob/master/examples/mini/programs_db.json"><abbr title="JavaScript Object Notation">JSON</abbr> tag database</a> constructed from
the programs of <a href="https://github.com/laowantong/paroxython/blob/master/examples/mini/programs">this</a> directory.</p>
<h2 id="note">Note</h2>
<p>For readability purposes, the output of <code>json.dumps()</code> is reformatted to fit each span
list on a single line, e.g.:</p>
<pre><code class="json">            &quot;flow/loop/exit/late&quot;: [
                [
                    3,
                    8
                ],
                [
                    6,
                    7
                ]
            ],
</code></pre>
<p>&hellip; is unwrap as:</p>
<pre><code class="json">            &quot;flow/loop/exit/late&quot;: [[3,8],[6,7]],
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L98-L137" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def get_json(self) -&gt; str:
    data = {
        &#34;programs&#34;: self.programs_infos,
        &#34;labels&#34;: dict(sorted(self.labels.items())),
        &#34;taxa&#34;: dict(sorted(self.taxa.items())),
        &#34;importations&#34;: dict(self.importations.items()),
        &#34;exportations&#34;: dict(self.exportations.items()),
    }
    text = json.dumps(data, indent=2) + &#34;\n&#34;
    text = regex.sub(r&#34;\s*\[\s+(\d+),\s+(\d+)\s+\](,?)\s+&#34;, r&#34;[\1,\2]\3&#34;, text)
    return text</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.TagDatabase.write_json"><code class="name flex">
<span>def <span class="ident">write_json</span></span>(<span>self, <br>db_path: Union[pathlib.Path, NoneType] = None<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Call <code><a title="paroxython.make_db.TagDatabase.get_json" href="#paroxython.make_db.TagDatabase.get_json">TagDatabase.get_json()</a></code> and write the result to a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>Optional[Path]</code>, optional</dt>
<dd>If not provided, and the directory provided to the
class constructor is <code>"foobar"</code>, falls back to <code>"foobar_db.json"</code> in the same parent
directory. Defaults to <code>None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L139-L149" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def write_json(self, db_path: Optional[Path] = None) -&gt; None:
    db_path = db_path or self.directory.parent / f&#34;{self.directory.name}_db.json&#34;
    print(f&#34;Writing {db_path}.&#34;)
    db_path.write_text(self.get_json())</code></pre>
</details>
</dd>
<dt id="paroxython.make_db.TagDatabase.write_sqlite"><code class="name flex">
<span>def <span class="ident">write_sqlite</span></span>(<span>self, <br>db_path: Union[pathlib.Path, NoneType] = None<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Dump the constructed <code><a title="paroxython.make_db.TagDatabase" href="#paroxython.make_db.TagDatabase">TagDatabase</a></code> object as a SQLite database (experimental).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>Optional[Path]</code>, optional</dt>
<dd>The path of the SQLite database. If not provided,
and the directory provided to the class constructor is <code>"foobar"</code>, falls back to
<code>"foobar_db.sqlite"</code> in the same parent directory. Defaults to <code>None</code>.</dd>
</dl>
<h2 id="description">Description</h2>
<p>Schema, purpose and example queries
<a href="user_manual/index.html#the-sqlite-database">in the user manual</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/make_db.py#L151-L242" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def write_sqlite(self, db_path: Optional[Path] = None) -&gt; None:
    db_path = db_path or self.directory.parent / f&#34;{self.directory.name}_db.sqlite&#34;
    print(f&#34;Writing {db_path}.&#34;)
    program_rows: List[Tuple] = []
    label_rows: List[Tuple] = []
    taxon_rows: List[Tuple] = []
    for (path, info) in self.programs_infos.items():
        source = f&#34;{path}\n\n&#34; + add_line_numbers(info[&#34;source&#34;])
        program_rows.append((path, info[&#34;timestamp&#34;], source))
        for (label_name, spans) in info[&#34;labels&#34;].items():
            (prefix, _, suffix) = label_name.partition(&#34;:&#34;)
            for span in spans:
                label_rows.append(
                    (
                        label_name,
                        prefix,
                        suffix,
                        &#34;-&#34;.join(map(str, span)) if span[0] != span[1] else str(span[0]),
                        span[0],
                        span[1],
                        path,
                    )
                )
        for (taxon_name, spans) in info[&#34;taxa&#34;].items():
            for span in spans:
                taxon_rows.append(
                    (
                        taxon_name,
                        &#34;-&#34;.join(map(str, span)) if span[0] != span[1] else str(span[0]),
                        span[0],
                        span[1],
                        path,
                    )
                )

    if db_path.exists():  # pragma: no cover / Python 3.8: use missing_ok=True parameter
        db_path.unlink()
    connexion = sqlite3.connect(str(db_path))  # str() for Python 3.6 compatibility
    c = connexion.cursor()

    fill = lambda columns: &#34;,&#34;.join(&#34;?&#34; * len(columns))
    program_columns = (
        &#34;program TEXT PRIMARY KEY&#34;,
        &#34;timestamp TEXT&#34;,
        &#34;source TEXT&#34;,
    )
    c.execute(f&#34;CREATE TABLE program ({&#39;,&#39;.join(program_columns)})&#34;)
    c.executemany(f&#34;INSERT INTO program VALUES ({fill(program_columns)})&#34;, program_rows)

    label_columns = (
        # use rowid as primary key
        &#34;label TEXT&#34;,
        &#34;label_prefix TEXT&#34;,
        &#34;label_suffix TEXT&#34;,
        &#34;span TEXT&#34;,
        &#34;span_start INTEGER&#34;,
        &#34;span_end INTEGER&#34;,
        &#34;program TEXT&#34;,
    )
    c.execute(
        f&#34;CREATE TABLE label ({&#39;,&#39;.join(label_columns)},&#34;
        &#34;FOREIGN KEY (program) REFERENCES program (program))&#34;
    )
    c.executemany(f&#34;INSERT INTO label VALUES ({fill(label_columns)})&#34;, label_rows)

    taxon_columns = (
        # use rowid as primary key
        &#34;taxon TEXT&#34;,
        &#34;span TEXT&#34;,
        &#34;span_start INTEGER&#34;,
        &#34;span_end INTEGER&#34;,
        &#34;program TEXT&#34;,
    )
    c.execute(
        f&#34;CREATE TABLE taxon ({&#39;,&#39;.join(taxon_columns)},&#34;
        &#34;FOREIGN KEY (program) REFERENCES program (program))&#34;
    )
    c.executemany(f&#34;INSERT INTO taxon VALUES ({fill(taxon_columns)})&#34;, taxon_rows)

    connexion.commit()
    connexion.close()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Paroxython Home" href="index.html">
<img src="https://laowantong.github.io/paroxython/resources/logo.png" alt="Paroxython logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="paroxython" href="index.html">paroxython</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="paroxython.make_db.collect_labels" href="#paroxython.make_db.collect_labels">collect_labels</a></code></li>
<li><code><a title="paroxython.make_db.map_labels_on_taxa" href="#paroxython.make_db.map_labels_on_taxa">map_labels_on_taxa</a></code></li>
<li><code><a title="paroxython.make_db.collect_taxa" href="#paroxython.make_db.collect_taxa">collect_taxa</a></code></li>
<li><code><a title="paroxython.make_db.compute_direct_importations" href="#paroxython.make_db.compute_direct_importations">compute_direct_importations</a></code></li>
<li><code><a title="paroxython.make_db.complete_and_collect_importations" href="#paroxython.make_db.complete_and_collect_importations">complete_and_collect_importations</a></code></li>
<li><code><a title="paroxython.make_db.compute_and_collect_exportations" href="#paroxython.make_db.compute_and_collect_exportations">compute_and_collect_exportations</a></code></li>
<li><code><a title="paroxython.make_db.prepared_labels" href="#paroxython.make_db.prepared_labels">prepared_labels</a></code></li>
<li><code><a title="paroxython.make_db.prepared_taxa" href="#paroxython.make_db.prepared_taxa">prepared_taxa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="paroxython.make_db.TagDatabase" href="#paroxython.make_db.TagDatabase">TagDatabase</a></code></h4>
<ul class="">
<li><code><a title="paroxython.make_db.TagDatabase.__init__" href="#paroxython.make_db.TagDatabase.__init__">__init__</a></code></li>
<li><code><a title="paroxython.make_db.TagDatabase.get_json" href="#paroxython.make_db.TagDatabase.get_json">get_json</a></code></li>
<li><code><a title="paroxython.make_db.TagDatabase.write_json" href="#paroxython.make_db.TagDatabase.write_json">write_json</a></code></li>
<li><code><a title="paroxython.make_db.TagDatabase.write_sqlite" href="#paroxython.make_db.TagDatabase.write_sqlite">write_sqlite</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>