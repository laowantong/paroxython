<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>paroxython.map_taxonomy API documentation</title>
<meta name="description" content="Translate labels into taxa …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<a href="https://github.com/laowantong/paroxython"><img style="position: absolute; top: 0; right: 0; border: 0; width: 150px; height: 150px" src="https://laowantong.github.io/paroxython/resources/source_on_github.png" alt="Source on GitHub"></a>
<style>.homelink{display:block}.homelink:hover{color:inherit}.homelink img{margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://laowantong.github.io/paroxython/map_taxonomy.html">
<link rel="icon" href="https://laowantong.github.io/paroxython/resources/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>paroxython.map_taxonomy</code></h1>
</header>
<section id="section-intro">
<p>Translate labels into taxa.</p>
<h2 id="description">Description</h2>
<p>This step comes after <code><a title="paroxython.label_programs" href="label_programs.html">paroxython.label_programs</a></code> has tagged a program with the <strong>labels</strong> specified
in <a href="https://github.com/laowantong/paroxython/blob/master/paroxython/resources/spec.md"><code>spec.md</code></a>. Its purpose is to convert these labels into <strong>taxa</strong> based on the rules defined (by
default) in <a href="https://github.com/laowantong/paroxython/blob/master/paroxython/resources/taxonomy.tsv"><code>taxonomy.tsv</code></a>.</p>
<h2 id="example">Example</h2>
<p>Let's return to the Jupyter notebook's cell given in the introduction:</p>
<pre><code class="python">1   %%paroxython labels
2   def fibonacci(n):
3       result = []
4       (a, b) = (0, 1)
5       while a &lt; n:
6           result.append(a)
7           (a, b) = (b, a + b)
8       return result
</code></pre>
<p>Note that the magic cell-command <code>%%paroxython</code> is now called with a <code>labels</code> argument. This
produces the following output (limited for brevity to its first four rows):</p>
<table>
<thead>
<tr>
<th align="left">Label</th>
<th align="left">Lines</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>addition_operator</code></td>
<td align="left">7</td>
</tr>
<tr>
<td align="left"><code>assignment</code></td>
<td align="left">3, 4, 7</td>
</tr>
<tr>
<td align="left"><code>assignment_lhs_identifier:a</code></td>
<td align="left">4, 7</td>
</tr>
<tr>
<td align="left"><code>assignment_lhs_identifier:b</code></td>
<td align="left">4, 7</td>
</tr>
</tbody>
</table>
<p>These labels are low-level tags, intended for internal use only. They still need to be translated
into the following taxa, which are the only tags of interest to the end user. For instance,
<code>"addition_operator"</code> will be translated into <code>"operator/arithmetic/addition"</code> (note that, unlike
a label, a taxon may feature one or several slashes, which indicate the nesting of notions). More
examples are given in the dedicated <a href="user_manual/index.html#taxonomy">section</a> of the user manual.</p>
<p>In fact, both labels and taxa are couples:</p>
<ul>
<li>Label: <code>("addition_operator", [(7, 7, "...")])</code>.</li>
<li>Taxon: <code>("operator/arithmetic/addition", {(7, 7, "..."): 1})</code>.</li>
</ul>
<p>The second member is slightly more complicated than a list of line numbers:</p>
<ul>
<li>For a label, it is a list of triples consisting of the start and end of the spanning lines,
and a third member, the path (here denoted by the ellipsis), which identifies unambiguously the
start of the span.</li>
<li>For a taxon, it is a <strong>bag</strong>, i.e. a dictionary associating such triples with the count of their
occurrences in the program.</li>
</ul>
<p>The paths being left untouched by the conversion, we will omit them from now on.</p>
<h3 id="deduplication">Deduplication</h3>
<ul>
<li>Labels:<ul>
<li><code>("assignment", [(3, 3), (4, 4), (7, 7)])</code>.</li>
<li><code>("single_assignment:result", [(3, 3)])</code>.</li>
<li><code>("parallel_assignment", [(4, 4), (7, 7)])</code>.</li>
<li><code>("slide", [(7, 7)])</code>.</li>
</ul>
</li>
<li>Taxa:<ul>
<li><code>("var/assignment/explicit/single", {(3, 3): 1})</code>.</li>
<li><code>("var/assignment/explicit/parallel", {(4, 4): 1})</code>.</li>
<li><code>("var/assignment/explicit/parallel/slide", {(7, 7): 1})</code>.</li>
</ul>
</li>
</ul>
<p>The example program features three distinct assignments. They can be categorized into:</p>
<ul>
<li>A single assignment on line 3
(<code>result = []</code>).</li>
<li>A parallel assignment on line 4 (<code>(a, b) = (0, 1)</code>).</li>
<li>A parallel assignment where a couple is updated by “sliding” the value of its second member to the
first position, on line 7 (<code>(a, b) = (b, a + b)</code>).</li>
</ul>
<p>As you can see, labelling all these produces a lot of span redundancies. For instance, the
assignment of line 7 is labelled three times, as <code>"assignment"</code>, <code>"parallel_assignment"</code> and
<code>"slide"</code>. Since the labels are not structured, this is the best that we can do.</p>
<p>Enter the taxa, whose production is triggered by the following taxonomy rows:</p>
<table>
<thead>
<tr>
<th align="left">Taxa (replacement patterns)</th>
<th align="left">Labels (search patterns)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>var/assignment/explicit</code></td>
<td align="left"><code>assignment\b.*</code></td>
</tr>
<tr>
<td align="left"><code>var/assignment/explicit/parallel</code></td>
<td align="left"><code>parallel_assignment:\d+</code></td>
</tr>
<tr>
<td align="left"><code>var/assignment/explicit/parallel/slide</code></td>
<td align="left"><code>slide</code></td>
</tr>
<tr>
<td align="left"><code>var/assignment/explicit/single</code></td>
<td align="left"><code>single_assignment:.+</code></td>
</tr>
</tbody>
</table>
<p>Initially, the conversion produces as many redundant spans as for the labels:</p>
<ul>
<li>Taxa:<ul>
<li><code>("var/assignment/explicit", {(3, 3): 1, (4, 4): 1, (7, 7): 1})</code>.</li>
<li><code>("var/assignment/explicit/single", {(3, 3): 1})</code>.</li>
<li><code>("var/assignment/explicit/parallel", {(4, 4): 1, (7, 7): 1})</code>.</li>
<li><code>("var/assignment/explicit/parallel/slide", {(7, 7): 1})</code>.</li>
</ul>
</li>
</ul>
<p>However, because of the tree-like structuring of taxa, it is possible to remove those occurrences
that are subject to further characterization (e.g., <code>var/assignment/explicit/parallel</code> on line 7 is
further characterized as <code>var/assignment/explicit/parallel/slide</code>), resulting in the list of taxa
given at the start of the section.</p>
<p>Note that the removal of spans has finally led to the elimination of the overly generic taxon
<code>var/assignment/explicit</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/map_taxonomy.py#L0-L382" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">from collections import Counter, defaultdict
from pathlib import Path
from typing import Callable, Dict, List, Optional, Tuple
from typing import Pattern as RegexPattern
from os.path import commonpath, dirname
from functools import lru_cache

import regex  # type: ignore

from .user_types import (
    LabelName,
    LabelPattern,
    Labels,
    Taxon,
    TaxonName,
    TaxonNames,
    TaxonPattern,
    Taxa,
    TaxaSpans,
)

__pdoc__ = {
    &#34;Taxonomy.__init__&#34;: True,
    &#34;Taxonomy&#34;: &#34;&#34;,
}


class Taxonomy:
    def __init__(
        self,
        taxonomy_path: Optional[Path] = None,
        **kwargs,
    ) -&gt; None:
        taxonomy_path = taxonomy_path or Path(dirname(__file__)) / &#34;resources&#34; / &#34;taxonomy.tsv&#34;
        tsv = taxonomy_path.read_text().partition(&#34;-- EOF&#34;)[0].strip()
        self.literal_labels: Dict[LabelName, TaxonNames] = defaultdict(list)
        self.compiled_labels: List[Tuple[RegexPattern, TaxonPattern]] = []
        for line in sorted(tsv.split(&#34;\n&#34;)[1:]):
            (taxon_value, label_value, *_) = line.strip().split(maxsplit=2)
            (taxon_pattern, label_pattern) = (TaxonPattern(taxon_value), LabelPattern(label_value))
            if is_literal(label_pattern):
                self.literal_labels[LabelName(label_pattern)].append(TaxonName(taxon_pattern))
            else:
                self.compiled_labels.append((regex.compile(f&#34;{label_pattern}$&#34;), taxon_pattern))
                # note: &#34;$&#34; is necessary: regex.fullmatch() has no regex.fullsub() counterpart

    @lru_cache(maxsize=None)
    def get_taxon_name_list(
        self, label_name: LabelName, looks_like_a_taxon: Callable = regex.compile(r&#34;^\w+/.+$&#34;).match
    ) -&gt; TaxonNames:
        if looks_like_a_taxon(label_name):
            return [TaxonName(label_name)]
        result: TaxonNames = self.literal_labels.get(label_name, [])
        for (label_regex_pattern, taxon_pattern) in self.compiled_labels:
            if label_regex_pattern.match(label_name):
                result.append(TaxonName(label_regex_pattern.sub(taxon_pattern, label_name)))
        return result

    def to_taxa(self, labels: Labels) -&gt; Taxa:
        acc: TaxaSpans = defaultdict(Counter)
        for (label_name, spans) in labels:
            for taxon_name in self.get_taxon_name_list(label_name):
                acc[taxon_name].update(spans)
        taxa = [Taxon(name, spans) for (name, spans) in sorted(acc.items())]
        return deduplicated_taxa(taxa)


def is_literal(label_pattern: LabelPattern) -&gt; bool:
    return label_pattern.replace(&#34;.&#34;, &#34;\\.&#34;) == regex.escape(label_pattern)


def deduplicated_taxa(taxa: Taxa) -&gt; Taxa:
    if len(taxa) &lt; 2:
        return taxa
    for (i, (name, spans)) in enumerate(taxa[1:], 1):
        for (previous_name, previous_spans) in reversed(taxa[:i]):
            # Since `&#34;/&#34;` happens to be a separator in both taxa and Unix-paths, `os.commonpath()`
            # comes in handy for extracting the common prefix of two taxa:
            common_prefix = commonpath((name, previous_name))
            if not common_prefix:
                break
            if previous_name == common_prefix:
                difference = spans - previous_spans
                previous_spans.subtract(spans)
                spans = difference
    result = []
    for (name, spans) in taxa:
        spans += Counter()  # suppress items whose count &lt;= 0
        if spans:  # if any item remains in the bag
            result.append(Taxon(name, spans))
    return result


if __name__ == &#34;__main__&#34;:
    from .goodies import couple_to_string
    from .label_programs import labelled_programs

    taxonomy = Taxonomy()
    for program in labelled_programs(Path(&#34;examples/simple/programs&#34;)):
        taxa = taxonomy.to_taxa(program.labels)
        if not taxa:
            continue
        width = min(40, max(len(&#34; &#34;.join(map(str, taxon.spans))) for taxon in taxa))
        for (name, spans) in taxa:
            span_string = &#34; &#34;.join(map(couple_to_string, sorted(set(spans))))
            print(f&#34;{span_string:&gt;{width}}\t{name}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="paroxython.map_taxonomy.is_literal"><code class="name flex">
<span>def <span class="ident">is_literal</span></span>(<span>label_pattern: LabelPattern) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tell whether a given regular expression pattern is literal, disregarding the dots.</p>
<h2 id="description">Description</h2>
<p>All label patterns of the taxonomy <abbr title="Tab Separated Values">TSV</abbr> file (second column) will be tested successively. For
instance, the label pattern <code>"external_free_call:print"</code> is literal, and then matches only
itself. Conversely, the label pattern <code>"internal_free_call:[[:upper:]].*"</code> contains some
non-literal characters such as <code>"["</code> and <code>"*"</code>, and then must be compiled into a regular
expression. A pattern is considered to be literal if it is equal to its escaped form, <strong>not
taking the dots into account</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In case not considering the dot as a metacharacter is a
problem, it is always possible to
force the interpretation of a pattern as non-literal by enclosing it in parentheses.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/map_taxonomy.py#L249-L264" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def is_literal(label_pattern: LabelPattern) -&gt; bool:
    return label_pattern.replace(&#34;.&#34;, &#34;\\.&#34;) == regex.escape(label_pattern)</code></pre>
</details>
</dd>
<dt id="paroxython.map_taxonomy.deduplicated_taxa"><code class="name flex">
<span>def <span class="ident">deduplicated_taxa</span></span>(<span>taxa: List[Taxon]) ‑> List[Taxon]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove from the given taxa those that are counted multiple times as prefixes of another ones.</p>
<h2 id="description">Description</h2>
<p>Consider the following program:</p>
<pre><code class="python">1   while n != 1:
2       if n % 2 == 0:
3           n = n // 2
4       else:
5           n = 3 * n + 1
</code></pre>
<p>It features exactly one literal integer on lines 1 and 3, and exactly two on lines 2 and 5.
Moreover, one of the literals of line 2 is zero. Therefore, the program is originally tagged
with the following two couples (among others):</p>
<pre><code class="python">[
    ...
    (&quot;type/number/integer/literal&quot;,
        {
            (1, 1): 1,
            (2, 2): 2,
            (3, 3): 1,
            (5, 5): 2,
        }
    ),
    (&quot;type/number/integer/literal/zero&quot;, {(2, 2): 1}),
    ...
]
</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>In the dictionary above, <code>(5, 5): 2</code> means that the taxon <code>"type/number/integer/literal"</code>
has 2 distinct occurrences spanning the lines 5 to 5 (namely, <code>3</code> and <code>1</code>). Such a
“counter” dictionary is called a <em>bag</em>, or <em>multiset</em>.</p>
</div>
<p>Now, every occurrence of a given taxon <strong>is</strong> an occurrence of any of its prefix. For
instance, an occurrence of the literal integer <code>0</code> is obviously an occurrence of a literal
integer. Currently, it is counted twice. The purpose of this function is to remove such
redundant counts. The longest taxon will be kept, and its prefix count decreased. Finally,
the following deduplicated list will be returned:</p>
<pre><code class="python">[
    ...
    (&quot;type/number/integer/literal&quot;,
        {
            (1, 1): 1,
            (2, 2): 1, # decremented
            (3, 3): 1,
            (5, 5): 2,
        }
    ),
    (&quot;type/number/integer/literal/zero&quot;, {(2, 2): 1}),
    ...
]
</code></pre>
<p>Decrementing a span count may result in the deletion of a taxon. For instance, on the same
program:</p>
<pre><code class="python">[
    ...
    (&quot;flow/loop&quot;, {(1, 5): 1},
    (&quot;flow/loop/exit/late&quot;, {(1, 5): 1},
    (&quot;flow/loop/while&quot;, {(1, 5): 1},
    ...
]
</code></pre>
<p>… becomes after deduplication:</p>
<pre><code class="python">[
    ...
    (&quot;flow/loop/exit/late&quot;, {(1, 5): 1},
    (&quot;flow/loop/while&quot;, {(1, 5): 1},
    ...
]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>taxa</code></strong> :&ensp;<code>Taxa</code></dt>
<dd>A list of couples, sorted lexicographically and consisting of a taxon name and
a bag (multiset) of its spans.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Taxa</code></dt>
<dd>The same list, deduplicated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/map_taxonomy.py#L267-L368" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def deduplicated_taxa(taxa: Taxa) -&gt; Taxa:
    if len(taxa) &lt; 2:
        return taxa
    for (i, (name, spans)) in enumerate(taxa[1:], 1):
        for (previous_name, previous_spans) in reversed(taxa[:i]):
            # Since `&#34;/&#34;` happens to be a separator in both taxa and Unix-paths, `os.commonpath()`
            # comes in handy for extracting the common prefix of two taxa:
            common_prefix = commonpath((name, previous_name))
            if not common_prefix:
                break
            if previous_name == common_prefix:
                difference = spans - previous_spans
                previous_spans.subtract(spans)
                spans = difference
    result = []
    for (name, spans) in taxa:
        spans += Counter()  # suppress items whose count &lt;= 0
        if spans:  # if any item remains in the bag
            result.append(Taxon(name, spans))
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="paroxython.map_taxonomy.Taxonomy"><code class="flex name class">
<span>class <span class="ident">Taxonomy</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/map_taxonomy.py#L133-L246" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">class Taxonomy:
    def __init__(
        self,
        taxonomy_path: Optional[Path] = None,
        **kwargs,
    ) -&gt; None:
        taxonomy_path = taxonomy_path or Path(dirname(__file__)) / &#34;resources&#34; / &#34;taxonomy.tsv&#34;
        tsv = taxonomy_path.read_text().partition(&#34;-- EOF&#34;)[0].strip()
        self.literal_labels: Dict[LabelName, TaxonNames] = defaultdict(list)
        self.compiled_labels: List[Tuple[RegexPattern, TaxonPattern]] = []
        for line in sorted(tsv.split(&#34;\n&#34;)[1:]):
            (taxon_value, label_value, *_) = line.strip().split(maxsplit=2)
            (taxon_pattern, label_pattern) = (TaxonPattern(taxon_value), LabelPattern(label_value))
            if is_literal(label_pattern):
                self.literal_labels[LabelName(label_pattern)].append(TaxonName(taxon_pattern))
            else:
                self.compiled_labels.append((regex.compile(f&#34;{label_pattern}$&#34;), taxon_pattern))
                # note: &#34;$&#34; is necessary: regex.fullmatch() has no regex.fullsub() counterpart

    @lru_cache(maxsize=None)
    def get_taxon_name_list(
        self, label_name: LabelName, looks_like_a_taxon: Callable = regex.compile(r&#34;^\w+/.+$&#34;).match
    ) -&gt; TaxonNames:
        if looks_like_a_taxon(label_name):
            return [TaxonName(label_name)]
        result: TaxonNames = self.literal_labels.get(label_name, [])
        for (label_regex_pattern, taxon_pattern) in self.compiled_labels:
            if label_regex_pattern.match(label_name):
                result.append(TaxonName(label_regex_pattern.sub(taxon_pattern, label_name)))
        return result

    def to_taxa(self, labels: Labels) -&gt; Taxa:
        acc: TaxaSpans = defaultdict(Counter)
        for (label_name, spans) in labels:
            for taxon_name in self.get_taxon_name_list(label_name):
                acc[taxon_name].update(spans)
        taxa = [Taxon(name, spans) for (name, spans) in sorted(acc.items())]
        return deduplicated_taxa(taxa)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="paroxython.map_taxonomy.Taxonomy.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, <br>taxonomy_path: Union[pathlib.Path, NoneType] = None, <br>**kwargs<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Read and pre-process the taxonomy specifications.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>taxonomy_path</code></strong> :&ensp;<code>Optional[Path]</code>, optional</dt>
<dd>The path of a two-columns <abbr title="Tab Separated Values">TSV</abbr> file
associating label (search) patterns with taxon (replacement) patterns. For better
readability, the taxa are listed on the first column, and the corresponding labels
(sometimes very long) on the second column. If not specified, the
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/resources/taxonomy.tsv">default taxonomy</a> is used.
Defaults to <code>None</code>.</dd>
</dl>
<h2 id="description">Description</h2>
<ol>
<li>Read the taxonomy, falling back to the provided default <a href="https://github.com/laowantong/paroxython/blob/master/paroxython/resources/taxonomy.tsv"><code>taxonomy.tsv</code></a>.</li>
<li>Drop the part starting with the string <code>"-- EOF"</code>, if any (this pre-processing
allows you to leave notes or drafts at the end of the file).</li>
<li>Distribute the remaining rows into two different accumulators, depending on the
“literality” of the label pattern:<ul>
<li><code>self.literal_labels</code> is a dictionary associating every <strong>literal</strong> label pattern,
that it to say, a label name, with a list of taxon names. Most of these lists are
singletons, but one can imagine that a unique label name could be associated with
multiple taxon names. As a dictionary, it allows O(1) lookups of any given label
pattern.</li>
<li><code>self.compiled_labels</code> is a list of couples, of which the first member is a
<strong>compiled</strong> label pattern, and the second member is a replacement pattern which may
contain backreferences to one or several capture groups of the label pattern. For
instance, it can include the couple <code>(regex.compile(r"index_shape:(\d+)$"),
r"subscript/index/shape/\1")</code>, which will be used to “translate” any occurrence of
the label name <code>"index_shape:3"</code> into the taxon name <code>"subscript/index/shape/3"</code>.
As an associative list, it only allows O(n) lookups a given label pattern.</li>
</ul>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/map_taxonomy.py#L134-L178" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def __init__(
    self,
    taxonomy_path: Optional[Path] = None,
    **kwargs,
) -&gt; None:
    taxonomy_path = taxonomy_path or Path(dirname(__file__)) / &#34;resources&#34; / &#34;taxonomy.tsv&#34;
    tsv = taxonomy_path.read_text().partition(&#34;-- EOF&#34;)[0].strip()
    self.literal_labels: Dict[LabelName, TaxonNames] = defaultdict(list)
    self.compiled_labels: List[Tuple[RegexPattern, TaxonPattern]] = []
    for line in sorted(tsv.split(&#34;\n&#34;)[1:]):
        (taxon_value, label_value, *_) = line.strip().split(maxsplit=2)
        (taxon_pattern, label_pattern) = (TaxonPattern(taxon_value), LabelPattern(label_value))
        if is_literal(label_pattern):
            self.literal_labels[LabelName(label_pattern)].append(TaxonName(taxon_pattern))
        else:
            self.compiled_labels.append((regex.compile(f&#34;{label_pattern}$&#34;), taxon_pattern))</code></pre>
</details>
</dd>
<dt id="paroxython.map_taxonomy.Taxonomy.get_taxon_name_list"><code class="name flex">
<span>def <span class="ident">get_taxon_name_list</span></span>(<span>self, <br>label_name: LabelName, <br>looks_like_a_taxon: Callable = &lt;built-in method match of regex&gt;<br>) ‑> List[TaxonName]</span>
</code></dt>
<dd>
<div class="desc"><p>Translate a label name into a list of taxon names.</p>
<h2 id="description">Description</h2>
<p>First of all, when a label looks like a taxon, it is returned without further ado.</p>
<p>For the rest, most of the work was done during the initialization, by constructing the
map <code>self.literal_labels</code> and the list <code>self.compiled_labels</code>. The given label name is
first looked up in the map, then matched successively against every regular expression
stored in the list.</p>
<p>The second step may be useful even if the first one has already produced one or several
translations. For instance, take a taxonomy defining the following associations:</p>
<table>
<thead>
<tr>
<th align="left">Taxa (replacement patterns)</th>
<th align="left">Labels (search patterns)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>call/subroutine/builtin/casting/\1</code></td>
<td align="left"><code>free_call:(list|dict)</code></td>
</tr>
<tr>
<td align="left"><code>type/sequence/list</code></td>
<td align="left"><code>free_call:list</code></td>
</tr>
</tbody>
</table>
<p>Suppose now that we pass the label <code>"free_call:list"</code>. The lookup in the map produces
a first translation: <code>"type/sequence/list"</code>. However, the linear search in the list
produces a second translation, namely: <code>"call/subroutine/builtin/casting/list"</code>.</p>
<pre><code class="python-repl">&gt;&gt;&gt; a_taxonomy_instance.get_taxon_name_list(&quot;free_call:list&quot;)
[
    &quot;type/sequence/list&quot;,
    &quot;call/subroutine/builtin/casting/list&quot;,
]
</code></pre>
<p>Therefore, the complexity of this function is linear in every case. However, its
<a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> avoids having to translate the
same label more than one time
(cf. <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">lru_cache</a>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/map_taxonomy.py#L181-L224" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">@lru_cache(maxsize=None)
def get_taxon_name_list(
    self, label_name: LabelName, looks_like_a_taxon: Callable = regex.compile(r&#34;^\w+/.+$&#34;).match
) -&gt; TaxonNames:
    if looks_like_a_taxon(label_name):
        return [TaxonName(label_name)]
    result: TaxonNames = self.literal_labels.get(label_name, [])
    for (label_regex_pattern, taxon_pattern) in self.compiled_labels:
        if label_regex_pattern.match(label_name):
            result.append(TaxonName(label_regex_pattern.sub(taxon_pattern, label_name)))
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.map_taxonomy.Taxonomy.to_taxa"><code class="name flex">
<span>def <span class="ident">to_taxa</span></span>(<span>self, <br>labels: List[Label]<br>) ‑> List[Taxon]</span>
</code></dt>
<dd>
<div class="desc"><p>Translate a list of labels to a list of taxa.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>labels</code></strong> :&ensp;<code>Labels</code></dt>
<dd>A list of labels, each label consisting in a name and a <strong>list</strong> of
spans.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Taxa</code></dt>
<dd>A sorted list of taxa, each taxon consisting in a name and a <strong>bag</strong> of spans.</dd>
</dl>
<h2 id="description">Description</h2>
<p>This simple method is the sole entry point of the object. It takes a list of labels,
accumulates their translations into taxa (cf. <code><a title="paroxython.map_taxonomy.Taxonomy.get_taxon_name_list" href="#paroxython.map_taxonomy.Taxonomy.get_taxon_name_list">Taxonomy.get_taxon_name_list()</a></code>) and
returns them deduplicated (cf. <code><a title="paroxython.map_taxonomy.deduplicated_taxa" href="#paroxython.map_taxonomy.deduplicated_taxa">deduplicated_taxa()</a></code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/map_taxonomy.py#L226-L246" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def to_taxa(self, labels: Labels) -&gt; Taxa:
    acc: TaxaSpans = defaultdict(Counter)
    for (label_name, spans) in labels:
        for taxon_name in self.get_taxon_name_list(label_name):
            acc[taxon_name].update(spans)
    taxa = [Taxon(name, spans) for (name, spans) in sorted(acc.items())]
    return deduplicated_taxa(taxa)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Paroxython Home" href="index.html">
<img src="https://laowantong.github.io/paroxython/resources/logo.png" alt="Paroxython logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#description">Description</a></li>
<li><a href="#example">Example</a><ul>
<li><a href="#deduplication">Deduplication</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="paroxython" href="index.html">paroxython</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="paroxython.map_taxonomy.is_literal" href="#paroxython.map_taxonomy.is_literal">is_literal</a></code></li>
<li><code><a title="paroxython.map_taxonomy.deduplicated_taxa" href="#paroxython.map_taxonomy.deduplicated_taxa">deduplicated_taxa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="paroxython.map_taxonomy.Taxonomy" href="#paroxython.map_taxonomy.Taxonomy">Taxonomy</a></code></h4>
<ul class="">
<li><code><a title="paroxython.map_taxonomy.Taxonomy.__init__" href="#paroxython.map_taxonomy.Taxonomy.__init__">__init__</a></code></li>
<li><code><a title="paroxython.map_taxonomy.Taxonomy.get_taxon_name_list" href="#paroxython.map_taxonomy.Taxonomy.get_taxon_name_list">get_taxon_name_list</a></code></li>
<li><code><a title="paroxython.map_taxonomy.Taxonomy.to_taxa" href="#paroxython.map_taxonomy.Taxonomy.to_taxa">to_taxa</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>