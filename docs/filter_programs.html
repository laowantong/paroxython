<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>paroxython.filter_programs API documentation</title>
<meta name="description" content="Evolve a set of selected programs and a set of taxa representing the imparted knowledge …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<a href="https://github.com/laowantong/paroxython"><img style="position: absolute; top: 0; right: 0; border: 0; width: 150px; height: 150px" src="https://laowantong.github.io/paroxython/resources/source_on_github.png" alt="Source on GitHub"></a>
<style>.homelink{display:block}.homelink:hover{color:inherit}.homelink img{margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://laowantong.github.io/paroxython/filter_programs.html">
<link rel="icon" href="https://laowantong.github.io/paroxython/resources/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>paroxython.filter_programs</code></h1>
</header>
<section id="section-intro">
<p>Evolve a set of selected programs and a set of taxa representing the imparted knowledge.</p>
<p>The class stores the state of these two sets and provides a collection of operators to be applied
on them during the execution of the pipeline (see <code><a title="paroxython.recommend_programs" href="recommend_programs.html">paroxython.recommend_programs</a></code>). Two additional
sets, less important, are maintained: the programs and the taxa to be hidden during the display of
the final result.</p>
<p><img alt="" src="resources/filter_flow.png"></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Initially, all programs in the tag database are selected. The three others sets are empty. As
the filter evolves, the first set can only shrink, and the other ones only increase.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L0-L571" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">from collections import Counter as counter
from collections import defaultdict
from itertools import permutations, product
from typing import Counter, Dict, Iterator, List, Tuple

import regex  # type: ignore

from .goodies import print_warning
from .normalize_predicate import normalize_predicate
from .user_types import (
    Criterion,
    JsonTagDatabase,
    Operation,
    Predicate,
    ProgramInfos,
    ProgramPath,
    ProgramPathSet,
    ProgramToPrograms,
    TaxonInfos,
    TaxonName,
    TaxonNameSet,
    TaxaPoorSpans,
)

__pdoc__ = {
    &#34;ProgramFilter.__init__&#34;: True,
    &#34;ProgramFilter&#34;: &#34;&#34;,
}


class ProgramFilter:

    # Initialization of the filter

    def __init__(self, db: JsonTagDatabase) -&gt; None:
        self.define_shortcuts(db)
        self.init_filter_state()
        self.add_imported_taxa()

    def define_shortcuts(self, db: JsonTagDatabase) -&gt; None:
        self.db_programs: ProgramInfos = db[&#34;programs&#34;]
        self.db_taxa: TaxonInfos = db[&#34;taxa&#34;]
        self.db_importations: ProgramToPrograms = db[&#34;importations&#34;]
        self.db_exportations: ProgramToPrograms = db[&#34;exportations&#34;]

    def init_filter_state(self) -&gt; None:
        self.selected_programs: ProgramPathSet = set(self.db_programs)
        self.imparted_knowledge: TaxonNameSet = set()
        self.hidden_taxa: TaxonNameSet = set()
        self.hidden_programs: ProgramPathSet = set()

    def add_imported_taxa(self) -&gt; None:
        for (exporter, importers) in self.db_exportations.items():
            exported_taxa = list(self.db_programs[exporter][&#34;taxa&#34;])
            for exported_taxon in exported_taxa:
                if exported_taxon.startswith(&#34;meta/&#34;):
                    continue
                for importer in importers:
                    importer_taxa = self.db_programs[importer][&#34;taxa&#34;]
                    if exported_taxon not in importer_taxa:
                        importer_taxa[exported_taxon] = []

    # Get the set of taxon names or program paths matching the given pattern.

    def taxa_of_pattern(self, pattern: str) -&gt; TaxonNameSet:
        match = regex.compile(fr&#34;{pattern}\b&#34;).match
        result: TaxonNameSet = set(filter(match, self.db_taxa))
        if not result:
            print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing taxon.&#34;)
        return result

    def programs_of_pattern(self, pattern: str) -&gt; ProgramPathSet:
        match = regex.compile(fr&#34;{pattern}&#34;).match
        result: ProgramPathSet = set(filter(match, self.db_programs))
        if not result:
            print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing program.&#34;)
        return result

    # Select programs from the taxa they feature, and vice versa.

    def taxa_of_programs(self, programs: ProgramPathSet, follow: bool = False) -&gt; TaxonNameSet:
        taxa: TaxonNameSet = set()
        for program in programs:
            if program in self.db_programs:
                for (taxon, spans) in self.db_programs[program][&#34;taxa&#34;].items():
                    if spans or follow:
                        # Either the taxon is featured directly or the imports must be followed.
                        taxa.add(taxon)
        return taxa

    def programs_of_taxa(self, taxa: TaxonNameSet, follow: bool = False) -&gt; ProgramPathSet:
        programs: ProgramPathSet = set()
        for taxon in taxa:
            programs.update(self.db_taxa.get(taxon, []))
        if follow:
            for program in list(programs):
                programs.update(self.db_exportations[program])
        return programs

    # Update the state of the filter by applying set operations with the given programs or taxa.

    def update_filter(
        self,
        criteria: List[Criterion],
        operation: Operation,
        quantifier: str,
    ) -&gt; None:
        if operation in (&#34;impart&#34;, &#34;hide&#34;):
            patterns = [str(criterion) for criterion in criteria]
            if operation == &#34;impart&#34;:
                (program_set, taxon_set) = self.programs_and_taxa_of_patterns(patterns)
                self.exclude_programs(program_set, follow=False)
                self.impart_taxa(taxon_set)
            else:
                (program_set, taxon_set) = self.programs_or_taxa_of_patterns(patterns)
                self.hidden_programs.update(program_set)
                self.hidden_taxa.update(taxon_set)
        else:
            program_bag = self.programs_of_criteria(criteria, follow=(operation == &#34;exclude&#34;))
            if quantifier == &#34;all&#34;:
                program_bag -= counter({program: len(criteria) - 1 for program in program_bag})
            if operation == &#34;include&#34;:
                self.include_programs(set(program_bag))
            else:  # necessarily &#34;exclude&#34;
                self.exclude_programs(set(program_bag), follow=True)

    def programs_and_taxa_of_patterns(
        self, patterns: List[str]
    ) -&gt; Tuple[ProgramPathSet, TaxonNameSet]:
        resulting_taxa: TaxonNameSet = set()
        resulting_programs: ProgramPathSet = set()
        for pattern in patterns:
            if pattern.endswith(&#34;.py&#34;):
                programs = self.programs_of_pattern(pattern)
                taxa = self.taxa_of_programs(programs, follow=False)
                resulting_programs.update(programs)
            else:
                taxa = self.taxa_of_pattern(pattern)
            resulting_taxa.update(taxa)
        return (resulting_programs, resulting_taxa)

    def programs_or_taxa_of_patterns(
        self, patterns: List[str]
    ) -&gt; Tuple[ProgramPathSet, TaxonNameSet]:
        resulting_taxa: TaxonNameSet = set()
        resulting_programs: ProgramPathSet = set()
        for pattern in patterns:
            if pattern.endswith(&#34;.py&#34;):
                resulting_programs.update(self.programs_of_pattern(pattern))
            else:
                resulting_taxa.update(self.taxa_of_pattern(pattern))
        return (resulting_programs, resulting_taxa)

    def programs_of_criteria(self, criteria: List[Criterion], follow: bool) -&gt; Counter[ProgramPath]:
        resulting_programs: Counter[ProgramPath] = counter()
        for criterion in criteria:
            if isinstance(criterion, str):  # the criterion is a pattern
                if criterion.endswith(&#34;.py&#34;):  # the pattern is a program pattern
                    programs = self.programs_of_pattern(criterion)
                else:  # the pattern is a label pattern
                    taxa = self.taxa_of_pattern(criterion)
                    programs = self.programs_of_taxa(taxa, follow=follow)
                resulting_programs.update(programs)
            elif isinstance(criterion, (list, tuple)) and len(criterion) == 3:
                (pattern_1, raw_predicate, pattern_2) = criterion
                (predicate, negated) = normalize_predicate(raw_predicate)
                function = self.programs_of_negated_triple if negated else self.programs_of_triple
                resulting_programs.update(function(pattern_1, predicate, pattern_2))
            else:
                print_warning(f&#34;criterion {repr(criterion)} cannot be included or excluded.&#34;)
        return resulting_programs

    def impart_taxa(self, taxa: TaxonNameSet) -&gt; None:
        for taxon in taxa:
            edges = taxon.split(&#34;/&#34;)
            for i in range(len(edges)):
                prefix = &#34;/&#34;.join(edges[: i + 1])
                self.imparted_knowledge.add(TaxonName(prefix))

    def include_programs(self, programs: ProgramPathSet) -&gt; None:
        self.selected_programs.intersection_update(programs)

    def exclude_programs(self, programs: ProgramPathSet, follow: bool) -&gt; None:
        self.selected_programs.difference_update(programs)
        if follow:
            for program in programs:
                self.selected_programs.difference_update(self.db_exportations.get(program, {}))

    # Deal with semantic triples of the form (taxon_pattern_1, taxon_pattern_2, predicate)

    def programs_of_triple(
        self,
        taxon_pattern_1: str,
        predicate: Predicate,
        taxon_pattern_2: str,
    ) -&gt; ProgramPathSet:
        taxa_1 = self.taxa_of_pattern(taxon_pattern_1)
        taxa_2 = self.taxa_of_pattern(taxon_pattern_2)
        programs_1 = self.programs_of_taxa(taxa_1)
        programs_2 = self.programs_of_taxa(taxa_2)
        result: ProgramPathSet = set()
        for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
            spans = self.db_programs[program][&#34;taxa&#34;]
            for (span_1, span_2) in self.iterate_on_spans(spans, taxa_1, taxa_2):
                if predicate(span_1, span_2):
                    result.add(program)
                    break
        return result

    def programs_of_negated_triple(
        self,
        taxon_pattern_1: str,
        predicate: Predicate,
        taxon_pattern_2: str,
    ) -&gt; ProgramPathSet:
        taxa_1 = self.taxa_of_pattern(taxon_pattern_1)
        taxa_2 = self.taxa_of_pattern(taxon_pattern_2)
        programs_1 = self.programs_of_taxa(taxa_1)
        programs_2 = self.programs_of_taxa(taxa_2)
        result: ProgramPathSet = programs_1  # by default, keep all programs featuring taxon_1
        for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
            spans = self.db_programs[program][&#34;taxa&#34;]
            exists_span_2_satisfying_predicate: Dict[Tuple, bool] = defaultdict(bool)
            for (span_1, span_2) in self.iterate_on_spans(spans, taxa_1, taxa_2):
                exists_span_2_satisfying_predicate[tuple(span_1)] |= predicate(span_1, span_2)
            if all(exists_span_2_satisfying_predicate.values()):
                # for any span_1, there is at least one span_2 such that predicate(span_1, span_2)
                result.remove(program)
        return result

    def iterate_on_spans(
        self,  # declared as an instance method to prevent pdoc3 from misplacing its documentation.
        spans: TaxaPoorSpans,
        taxa_1: TaxonNameSet,
        taxa_2: TaxonNameSet,
    ) -&gt; Iterator:
        for (taxon_1, taxon_2) in product(taxa_1, taxa_2):
            if taxon_1 in spans and taxon_2 in spans:
                if taxon_1 == taxon_2:  # exclude diagonal from iteration
                    yield from permutations(spans[taxon_1], 2)
                else:
                    yield from product(spans[taxon_1], spans[taxon_2])


# &lt;graphviz&gt;
# &#34;__init__&#34; -&gt; &#34;define_shortcuts&#34;
# &#34;__init__&#34; -&gt; &#34;init_filter_state&#34;
# &#34;__init__&#34; -&gt; &#34;add_imported_taxa&#34;
# &#34;init_filter_state&#34; -&gt; &#34;taxa_of_programs&#34;  [style=invis]
# &#34;update_filter&#34; -&gt; &#34;programs_and_taxa_of_patterns&#34;
# &#34;update_filter&#34; -&gt; &#34;programs_or_taxa_of_patterns&#34;
# &#34;programs_and_taxa_of_patterns&#34; -&gt; &#34;programs_of_pattern&#34;
# &#34;programs_and_taxa_of_patterns&#34; -&gt; &#34;taxa_of_programs&#34;
# &#34;programs_and_taxa_of_patterns&#34; -&gt; &#34;taxa_of_pattern&#34;
# &#34;programs_or_taxa_of_patterns&#34; -&gt; &#34;programs_of_pattern&#34;
# &#34;programs_or_taxa_of_patterns&#34; -&gt; &#34;taxa_of_pattern&#34;
# &#34;update_filter&#34; -&gt; &#34;programs_of_criteria&#34;
# &#34;programs_of_criteria&#34; -&gt; &#34;programs_of_pattern&#34;
# &#34;programs_of_criteria&#34; -&gt; &#34;programs_of_taxa&#34;
# &#34;programs_of_criteria&#34; -&gt; &#34;taxa_of_pattern&#34;
# &#34;programs_of_criteria&#34; -&gt; &#34;programs_of_triple&#34;
# &#34;programs_of_triple&#34; -&gt; &#34;taxa_of_pattern&#34;
# &#34;programs_of_triple&#34; -&gt; &#34;programs_of_taxa&#34;
# &#34;programs_of_triple&#34; -&gt; &#34;iterate_on_spans&#34;
# &#34;programs_of_criteria&#34; -&gt; &#34;programs_of_negated_triple&#34;
# &#34;programs_of_negated_triple&#34; -&gt; &#34;taxa_of_pattern&#34;
# &#34;programs_of_negated_triple&#34; -&gt; &#34;programs_of_taxa&#34;
# &#34;programs_of_negated_triple&#34; -&gt; &#34;iterate_on_spans&#34;
# &#34;update_filter&#34; -&gt; &#34;impart_taxa&#34;
# &#34;update_filter&#34; -&gt; &#34;include_programs&#34;
# &#34;update_filter&#34; -&gt; &#34;exclude_programs&#34;
# &lt;/graphviz&gt;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="paroxython.filter_programs.ProgramFilter"><code class="flex name class">
<span>class <span class="ident">ProgramFilter</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L45-L542" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">class ProgramFilter:

    # Initialization of the filter

    def __init__(self, db: JsonTagDatabase) -&gt; None:
        self.define_shortcuts(db)
        self.init_filter_state()
        self.add_imported_taxa()

    def define_shortcuts(self, db: JsonTagDatabase) -&gt; None:
        self.db_programs: ProgramInfos = db[&#34;programs&#34;]
        self.db_taxa: TaxonInfos = db[&#34;taxa&#34;]
        self.db_importations: ProgramToPrograms = db[&#34;importations&#34;]
        self.db_exportations: ProgramToPrograms = db[&#34;exportations&#34;]

    def init_filter_state(self) -&gt; None:
        self.selected_programs: ProgramPathSet = set(self.db_programs)
        self.imparted_knowledge: TaxonNameSet = set()
        self.hidden_taxa: TaxonNameSet = set()
        self.hidden_programs: ProgramPathSet = set()

    def add_imported_taxa(self) -&gt; None:
        for (exporter, importers) in self.db_exportations.items():
            exported_taxa = list(self.db_programs[exporter][&#34;taxa&#34;])
            for exported_taxon in exported_taxa:
                if exported_taxon.startswith(&#34;meta/&#34;):
                    continue
                for importer in importers:
                    importer_taxa = self.db_programs[importer][&#34;taxa&#34;]
                    if exported_taxon not in importer_taxa:
                        importer_taxa[exported_taxon] = []

    # Get the set of taxon names or program paths matching the given pattern.

    def taxa_of_pattern(self, pattern: str) -&gt; TaxonNameSet:
        match = regex.compile(fr&#34;{pattern}\b&#34;).match
        result: TaxonNameSet = set(filter(match, self.db_taxa))
        if not result:
            print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing taxon.&#34;)
        return result

    def programs_of_pattern(self, pattern: str) -&gt; ProgramPathSet:
        match = regex.compile(fr&#34;{pattern}&#34;).match
        result: ProgramPathSet = set(filter(match, self.db_programs))
        if not result:
            print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing program.&#34;)
        return result

    # Select programs from the taxa they feature, and vice versa.

    def taxa_of_programs(self, programs: ProgramPathSet, follow: bool = False) -&gt; TaxonNameSet:
        taxa: TaxonNameSet = set()
        for program in programs:
            if program in self.db_programs:
                for (taxon, spans) in self.db_programs[program][&#34;taxa&#34;].items():
                    if spans or follow:
                        # Either the taxon is featured directly or the imports must be followed.
                        taxa.add(taxon)
        return taxa

    def programs_of_taxa(self, taxa: TaxonNameSet, follow: bool = False) -&gt; ProgramPathSet:
        programs: ProgramPathSet = set()
        for taxon in taxa:
            programs.update(self.db_taxa.get(taxon, []))
        if follow:
            for program in list(programs):
                programs.update(self.db_exportations[program])
        return programs

    # Update the state of the filter by applying set operations with the given programs or taxa.

    def update_filter(
        self,
        criteria: List[Criterion],
        operation: Operation,
        quantifier: str,
    ) -&gt; None:
        if operation in (&#34;impart&#34;, &#34;hide&#34;):
            patterns = [str(criterion) for criterion in criteria]
            if operation == &#34;impart&#34;:
                (program_set, taxon_set) = self.programs_and_taxa_of_patterns(patterns)
                self.exclude_programs(program_set, follow=False)
                self.impart_taxa(taxon_set)
            else:
                (program_set, taxon_set) = self.programs_or_taxa_of_patterns(patterns)
                self.hidden_programs.update(program_set)
                self.hidden_taxa.update(taxon_set)
        else:
            program_bag = self.programs_of_criteria(criteria, follow=(operation == &#34;exclude&#34;))
            if quantifier == &#34;all&#34;:
                program_bag -= counter({program: len(criteria) - 1 for program in program_bag})
            if operation == &#34;include&#34;:
                self.include_programs(set(program_bag))
            else:  # necessarily &#34;exclude&#34;
                self.exclude_programs(set(program_bag), follow=True)

    def programs_and_taxa_of_patterns(
        self, patterns: List[str]
    ) -&gt; Tuple[ProgramPathSet, TaxonNameSet]:
        resulting_taxa: TaxonNameSet = set()
        resulting_programs: ProgramPathSet = set()
        for pattern in patterns:
            if pattern.endswith(&#34;.py&#34;):
                programs = self.programs_of_pattern(pattern)
                taxa = self.taxa_of_programs(programs, follow=False)
                resulting_programs.update(programs)
            else:
                taxa = self.taxa_of_pattern(pattern)
            resulting_taxa.update(taxa)
        return (resulting_programs, resulting_taxa)

    def programs_or_taxa_of_patterns(
        self, patterns: List[str]
    ) -&gt; Tuple[ProgramPathSet, TaxonNameSet]:
        resulting_taxa: TaxonNameSet = set()
        resulting_programs: ProgramPathSet = set()
        for pattern in patterns:
            if pattern.endswith(&#34;.py&#34;):
                resulting_programs.update(self.programs_of_pattern(pattern))
            else:
                resulting_taxa.update(self.taxa_of_pattern(pattern))
        return (resulting_programs, resulting_taxa)

    def programs_of_criteria(self, criteria: List[Criterion], follow: bool) -&gt; Counter[ProgramPath]:
        resulting_programs: Counter[ProgramPath] = counter()
        for criterion in criteria:
            if isinstance(criterion, str):  # the criterion is a pattern
                if criterion.endswith(&#34;.py&#34;):  # the pattern is a program pattern
                    programs = self.programs_of_pattern(criterion)
                else:  # the pattern is a label pattern
                    taxa = self.taxa_of_pattern(criterion)
                    programs = self.programs_of_taxa(taxa, follow=follow)
                resulting_programs.update(programs)
            elif isinstance(criterion, (list, tuple)) and len(criterion) == 3:
                (pattern_1, raw_predicate, pattern_2) = criterion
                (predicate, negated) = normalize_predicate(raw_predicate)
                function = self.programs_of_negated_triple if negated else self.programs_of_triple
                resulting_programs.update(function(pattern_1, predicate, pattern_2))
            else:
                print_warning(f&#34;criterion {repr(criterion)} cannot be included or excluded.&#34;)
        return resulting_programs

    def impart_taxa(self, taxa: TaxonNameSet) -&gt; None:
        for taxon in taxa:
            edges = taxon.split(&#34;/&#34;)
            for i in range(len(edges)):
                prefix = &#34;/&#34;.join(edges[: i + 1])
                self.imparted_knowledge.add(TaxonName(prefix))

    def include_programs(self, programs: ProgramPathSet) -&gt; None:
        self.selected_programs.intersection_update(programs)

    def exclude_programs(self, programs: ProgramPathSet, follow: bool) -&gt; None:
        self.selected_programs.difference_update(programs)
        if follow:
            for program in programs:
                self.selected_programs.difference_update(self.db_exportations.get(program, {}))

    # Deal with semantic triples of the form (taxon_pattern_1, taxon_pattern_2, predicate)

    def programs_of_triple(
        self,
        taxon_pattern_1: str,
        predicate: Predicate,
        taxon_pattern_2: str,
    ) -&gt; ProgramPathSet:
        taxa_1 = self.taxa_of_pattern(taxon_pattern_1)
        taxa_2 = self.taxa_of_pattern(taxon_pattern_2)
        programs_1 = self.programs_of_taxa(taxa_1)
        programs_2 = self.programs_of_taxa(taxa_2)
        result: ProgramPathSet = set()
        for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
            spans = self.db_programs[program][&#34;taxa&#34;]
            for (span_1, span_2) in self.iterate_on_spans(spans, taxa_1, taxa_2):
                if predicate(span_1, span_2):
                    result.add(program)
                    break
        return result

    def programs_of_negated_triple(
        self,
        taxon_pattern_1: str,
        predicate: Predicate,
        taxon_pattern_2: str,
    ) -&gt; ProgramPathSet:
        taxa_1 = self.taxa_of_pattern(taxon_pattern_1)
        taxa_2 = self.taxa_of_pattern(taxon_pattern_2)
        programs_1 = self.programs_of_taxa(taxa_1)
        programs_2 = self.programs_of_taxa(taxa_2)
        result: ProgramPathSet = programs_1  # by default, keep all programs featuring taxon_1
        for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
            spans = self.db_programs[program][&#34;taxa&#34;]
            exists_span_2_satisfying_predicate: Dict[Tuple, bool] = defaultdict(bool)
            for (span_1, span_2) in self.iterate_on_spans(spans, taxa_1, taxa_2):
                exists_span_2_satisfying_predicate[tuple(span_1)] |= predicate(span_1, span_2)
            if all(exists_span_2_satisfying_predicate.values()):
                # for any span_1, there is at least one span_2 such that predicate(span_1, span_2)
                result.remove(program)
        return result

    def iterate_on_spans(
        self,  # declared as an instance method to prevent pdoc3 from misplacing its documentation.
        spans: TaxaPoorSpans,
        taxa_1: TaxonNameSet,
        taxa_2: TaxonNameSet,
    ) -&gt; Iterator:
        for (taxon_1, taxon_2) in product(taxa_1, taxa_2):
            if taxon_1 in spans and taxon_2 in spans:
                if taxon_1 == taxon_2:  # exclude diagonal from iteration
                    yield from permutations(spans[taxon_1], 2)
                else:
                    yield from product(spans[taxon_1], spans[taxon_2])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="paroxython.filter_programs.ProgramFilter.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, <br>db: JsonTagDatabase<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Call <code>define_shortcuts()</code>,
<code>init_filter_state()</code> and <code>add_imported_taxa()</code> (below).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L49-L53" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def __init__(self, db: JsonTagDatabase) -&gt; None:
    self.define_shortcuts(db)
    self.init_filter_state()
    self.add_imported_taxa()</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.define_shortcuts"><code class="name flex">
<span>def <span class="ident">define_shortcuts</span></span>(<span>self, <br>db: JsonTagDatabase<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Define some attributes that point directly to the main parts of the tag database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L55-L60" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def define_shortcuts(self, db: JsonTagDatabase) -&gt; None:
    self.db_programs: ProgramInfos = db[&#34;programs&#34;]
    self.db_taxa: TaxonInfos = db[&#34;taxa&#34;]
    self.db_importations: ProgramToPrograms = db[&#34;importations&#34;]
    self.db_exportations: ProgramToPrograms = db[&#34;exportations&#34;]</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.init_filter_state"><code class="name flex">
<span>def <span class="ident">init_filter_state</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Select all programs and define the imparted knowledge as empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L62-L67" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def init_filter_state(self) -&gt; None:
    self.selected_programs: ProgramPathSet = set(self.db_programs)
    self.imparted_knowledge: TaxonNameSet = set()
    self.hidden_taxa: TaxonNameSet = set()
    self.hidden_programs: ProgramPathSet = set()</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.add_imported_taxa"><code class="name flex">
<span>def <span class="ident">add_imported_taxa</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Copy under each program the taxa it featured by importation.</p>
<h2 id="description">Description</h2>
<p>Initially, the <abbr title="JavaScript Object Notation">JSON</abbr> tag database stores under each program all the taxa it features
<em>directly</em>, for instance:</p>
<pre><code>{
    &quot;programs&quot;: {
        ...
        &quot;fizzbuzz.py&quot;: {
            ...
            &quot;taxa&quot;: {
                &quot;call/subroutine/builtin/print&quot;: [[4,4],[6,6],[8,8],[10,10]],
                &quot;call/subroutine/builtin/range&quot;: [[2,2]],
                &quot;flow/conditional&quot;: [[3,10],[5,10],[7,10]],
                ...
</code></pre>
<p>For performance and readability reasons, it is useful to complete such a dictionary
with the taxa which are featured <em>indirectly</em>, namely those featured by the imported
programs. For instance, assuming that <code>fizzbuzz.py</code> imports <code>collatz.py</code>, we must
copy the taxa featured by the latter, but not by the former program, namely:</p>
<pre><code>                &quot;operator/arithmetic/multiplication&quot;: [],
                &quot;def/argument/arg&quot;: [],
                &quot;def/subroutine/procedure&quot;: [],
                ...
</code></pre>
<h2 id="notes">Notes</h2>
<ul>
<li>The spans of the imported taxa are not copied, but replaced by an empty list (it is
enough to know that a certain taxon is only featured by an imported program, not on
which lines of which program).</li>
<li>All imported taxa starting with <code>"meta/"</code> are by convention excluded from the
copy.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L69-L115" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def add_imported_taxa(self) -&gt; None:
    for (exporter, importers) in self.db_exportations.items():
        exported_taxa = list(self.db_programs[exporter][&#34;taxa&#34;])
        for exported_taxon in exported_taxa:
            if exported_taxon.startswith(&#34;meta/&#34;):
                continue
            for importer in importers:
                importer_taxa = self.db_programs[importer][&#34;taxa&#34;]
                if exported_taxon not in importer_taxa:
                    importer_taxa[exported_taxon] = []</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.taxa_of_pattern"><code class="name flex">
<span>def <span class="ident">taxa_of_pattern</span></span>(<span>self, <br>pattern: str<br>) ‑> Set[TaxonName]</span>
</code></dt>
<dd>
<div class="desc"><p>Find all the existing taxa matching the given regular expression pattern.</p>
<h2 id="note">Note</h2>
<p>All taxa are searched, not just the ones featured by a selected program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L119-L129" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def taxa_of_pattern(self, pattern: str) -&gt; TaxonNameSet:
    match = regex.compile(fr&#34;{pattern}\b&#34;).match
    result: TaxonNameSet = set(filter(match, self.db_taxa))
    if not result:
        print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing taxon.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_of_pattern"><code class="name flex">
<span>def <span class="ident">programs_of_pattern</span></span>(<span>self, <br>pattern: str<br>) ‑> Set[ProgramPath]</span>
</code></dt>
<dd>
<div class="desc"><p>Find all the existing programs matching the given regular expression pattern.</p>
<h2 id="note">Note</h2>
<p>All programs are searched, not just the selected ones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L131-L141" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_of_pattern(self, pattern: str) -&gt; ProgramPathSet:
    match = regex.compile(fr&#34;{pattern}&#34;).match
    result: ProgramPathSet = set(filter(match, self.db_programs))
    if not result:
        print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing program.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.taxa_of_programs"><code class="name flex">
<span>def <span class="ident">taxa_of_programs</span></span>(<span>self, <br>programs: Set[ProgramPath], <br>follow: bool = False<br>) ‑> Set[TaxonName]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the taxa featured (or optionally imported) by any given program.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>ProgramPathSet</code></dt>
<dd>Program paths. The non-existing ones are silently ignored.</dd>
<dt><strong><code>follow</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, include the taxa featured by the imported programs.
Defaults to <code>False</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Let <code>p1</code>, <code>p2</code>, <code>p3</code> be three programs, with <code>p3</code> importing <code>p2</code>, and <code>p2</code> importing
<code>p1</code>. Let <code>t</code> be a taxon featured by <code>p1</code> only. Then:</p>
<pre><code class="python-repl">&gt;&gt;&gt; t in taxa_of_programs({p1})
True
&gt;&gt;&gt; t in taxa_of_programs({p2})
False
&gt;&gt;&gt; t in taxa_of_programs({p3}, follow=True)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L145-L170" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def taxa_of_programs(self, programs: ProgramPathSet, follow: bool = False) -&gt; TaxonNameSet:
    taxa: TaxonNameSet = set()
    for program in programs:
        if program in self.db_programs:
            for (taxon, spans) in self.db_programs[program][&#34;taxa&#34;].items():
                if spans or follow:
                    # Either the taxon is featured directly or the imports must be followed.
                    taxa.add(taxon)
    return taxa</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_of_taxa"><code class="name flex">
<span>def <span class="ident">programs_of_taxa</span></span>(<span>self, <br>taxa: Set[TaxonName], <br>follow: bool = False<br>) ‑> Set[ProgramPath]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the programs featuring (or optionally importing) any given taxon.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>taxa</code></strong> :&ensp;<code>TaxonNameSet</code></dt>
<dd>Taxon names. The non-existing ones are silently ignored.</dd>
<dt><strong><code>follow</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, include the programs importing at least one program
featuring at least one taxon. Defaults to <code>False</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<p>With <code>p1</code>, <code>p2</code>, <code>p3</code> and <code>t</code> as in the example of <code><a title="paroxython.filter_programs.ProgramFilter.taxa_of_programs" href="#paroxython.filter_programs.ProgramFilter.taxa_of_programs">ProgramFilter.taxa_of_programs()</a></code>:</p>
<pre><code class="python-repl">&gt;&gt;&gt; programs_of_taxa({t})
{p1}
&gt;&gt;&gt; programs_of_taxa({t}, follow=True)
{p1, p2, p3}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L172-L193" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_of_taxa(self, taxa: TaxonNameSet, follow: bool = False) -&gt; ProgramPathSet:
    programs: ProgramPathSet = set()
    for taxon in taxa:
        programs.update(self.db_taxa.get(taxon, []))
    if follow:
        for program in list(programs):
            programs.update(self.db_exportations[program])
    return programs</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.update_filter"><code class="name flex">
<span>def <span class="ident">update_filter</span></span>(<span>self, <br>criteria: List[Union[str, Tuple[str, str, str]]], <br>operation: Operation, <br>quantifier: str<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update the selected programs and/or impart the associated taxa and/or mark them as hidden.</p>
<h2 id="description">Description</h2>
<ul>
<li>If the operation is <code>"impart"</code>:<ul>
<li>calculate the appropriate sets of programs and taxa;</li>
<li>remove these programs from <code>self.selected_programs</code>;</li>
<li>add these taxa to <code>self.imparted_knowledge</code>.</li>
</ul>
</li>
<li>If the operation is <code>"hide"</code>:<ul>
<li>calculate the appropriate sets of programs and taxa;</li>
<li>add these taxa to <code>self.hidden_taxa</code>.</li>
</ul>
</li>
<li>Otherwise (the operation is either <code>"include"</code> or <code>"exclude"</code>):<ul>
<li>calculate the appropriate bag of programs: this bag counts, for each program,
the number of criteria they meet (maximum: size of <code>criteria</code>);</li>
<li>if <code>quantifier</code> is <code>"all"</code>, remove from this bag all programs which do not
meet at least one criterion;</li>
<li>include or exclude the resulting programs. Note that the <code>"exclude"</code> operation
extends to the programs which import the resulting ones: if the user wants to
exclude a program, she obviously expects that the programs which require it
are excluded too.</li>
</ul>
</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>criteria</code></strong> :&ensp;<code>List[Criterion]</code></dt>
<dd>A list of criteria, i.e., a mix of regular expression
patterns (strings) and/or predicates (triples).</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>Operation</code></dt>
<dd>Either <code>"impart"</code>, <code>"hide"</code>, <code>"include"</code> or <code>"exclude"</code>.</dd>
<dt><strong><code>quantifier</code></strong> :&ensp;<code>str</code></dt>
<dd>Either <code>"any"</code> or <code>"all"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L197-L246" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def update_filter(
    self,
    criteria: List[Criterion],
    operation: Operation,
    quantifier: str,
) -&gt; None:
    if operation in (&#34;impart&#34;, &#34;hide&#34;):
        patterns = [str(criterion) for criterion in criteria]
        if operation == &#34;impart&#34;:
            (program_set, taxon_set) = self.programs_and_taxa_of_patterns(patterns)
            self.exclude_programs(program_set, follow=False)
            self.impart_taxa(taxon_set)
        else:
            (program_set, taxon_set) = self.programs_or_taxa_of_patterns(patterns)
            self.hidden_programs.update(program_set)
            self.hidden_taxa.update(taxon_set)
    else:
        program_bag = self.programs_of_criteria(criteria, follow=(operation == &#34;exclude&#34;))
        if quantifier == &#34;all&#34;:
            program_bag -= counter({program: len(criteria) - 1 for program in program_bag})
        if operation == &#34;include&#34;:
            self.include_programs(set(program_bag))
        else:  # necessarily &#34;exclude&#34;
            self.exclude_programs(set(program_bag), follow=True)</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_and_taxa_of_patterns"><code class="name flex">
<span>def <span class="ident">programs_and_taxa_of_patterns</span></span>(<span>self, <br>patterns: List[str]<br>) ‑> Tuple[Set[ProgramPath], Set[TaxonName]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the sets of programs and taxa matching at least one of the patterns.</p>
<h2 id="description">Description</h2>
<p>Each pattern is a string which is interpreted either as:</p>
<ul>
<li>a program path pattern (ending with <code>".py"</code>). All programs matching it are accumulated
in the result, <em>along with any taxon they feature, directly or by importation, this
being the only difference with <code><a title="paroxython.filter_programs.ProgramFilter.programs_or_taxa_of_patterns" href="#paroxython.filter_programs.ProgramFilter.programs_or_taxa_of_patterns">ProgramFilter.programs_or_taxa_of_patterns()</a></code></em>;</li>
<li>or a taxon name pattern. All taxa matching it are accumulated in the result.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patterns</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A list of regular expression patterns (strings).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ProgramPathSet, TaxonNameSet]</code></dt>
<dd>The couple of accumulated programs and taxa.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L248-L277" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_and_taxa_of_patterns(
    self, patterns: List[str]
) -&gt; Tuple[ProgramPathSet, TaxonNameSet]:
    resulting_taxa: TaxonNameSet = set()
    resulting_programs: ProgramPathSet = set()
    for pattern in patterns:
        if pattern.endswith(&#34;.py&#34;):
            programs = self.programs_of_pattern(pattern)
            taxa = self.taxa_of_programs(programs, follow=False)
            resulting_programs.update(programs)
        else:
            taxa = self.taxa_of_pattern(pattern)
        resulting_taxa.update(taxa)
    return (resulting_programs, resulting_taxa)</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_or_taxa_of_patterns"><code class="name flex">
<span>def <span class="ident">programs_or_taxa_of_patterns</span></span>(<span>self, <br>patterns: List[str]<br>) ‑> Tuple[Set[ProgramPath], Set[TaxonName]]</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="paroxython.filter_programs.ProgramFilter.programs_and_taxa_of_patterns" href="#paroxython.filter_programs.ProgramFilter.programs_and_taxa_of_patterns">ProgramFilter.programs_and_taxa_of_patterns()</a></code>, minus the part in <em>italics</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L279-L290" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_or_taxa_of_patterns(
    self, patterns: List[str]
) -&gt; Tuple[ProgramPathSet, TaxonNameSet]:
    resulting_taxa: TaxonNameSet = set()
    resulting_programs: ProgramPathSet = set()
    for pattern in patterns:
        if pattern.endswith(&#34;.py&#34;):
            resulting_programs.update(self.programs_of_pattern(pattern))
        else:
            resulting_taxa.update(self.taxa_of_pattern(pattern))
    return (resulting_programs, resulting_taxa)</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_of_criteria"><code class="name flex">
<span>def <span class="ident">programs_of_criteria</span></span>(<span>self, <br>criteria: List[Union[str, Tuple[str, str, str]]], <br>follow: bool<br>) ‑> Counter[ProgramPath]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the set of programs that meet at least one of the criteria.</p>
<h2 id="description">Description</h2>
<p>Each criterion may be either:</p>
<ul>
<li>a string, which will be interpreted either as:<ul>
<li>a program path pattern (ending with <code>".py"</code>). All programs matching it are
accumulated in the result;</li>
<li>or a taxon name pattern. All programs featuring at least one taxon matching it
are accumulated in the result. If the operation is <code>"exclude"</code>, this set is
extended to the programs which import (either directly or by transitivity) at
least one of its members;</li>
</ul>
</li>
<li>a triple consisting in a “subject” pattern, a predicate (positive or negative)
and an ”object” pattern. This predicate is normalized and, depending on its
“sign”, evaluated on the patterns by either <code><a title="paroxython.filter_programs.ProgramFilter.programs_of_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_triple">ProgramFilter.programs_of_triple()</a></code> or
<code><a title="paroxython.filter_programs.ProgramFilter.programs_of_negated_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_negated_triple">ProgramFilter.programs_of_negated_triple()</a></code>.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>criteria</code></strong> :&ensp;<code>List[Criterion]</code></dt>
<dd>A list of criteria, i.e., a mix of regular expression
patterns (strings) and/or predicates (triples).</dd>
<dt><strong><code>follow</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, extend the result with all the programs which import (either
directly or by transitivity) at least one program meeting a criterion.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Counter[ProgramPath]</code></dt>
<dd>A bag (multiset) counting, for each resulting program, the number
of criteria it meets.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L292-L336" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_of_criteria(self, criteria: List[Criterion], follow: bool) -&gt; Counter[ProgramPath]:
    resulting_programs: Counter[ProgramPath] = counter()
    for criterion in criteria:
        if isinstance(criterion, str):  # the criterion is a pattern
            if criterion.endswith(&#34;.py&#34;):  # the pattern is a program pattern
                programs = self.programs_of_pattern(criterion)
            else:  # the pattern is a label pattern
                taxa = self.taxa_of_pattern(criterion)
                programs = self.programs_of_taxa(taxa, follow=follow)
            resulting_programs.update(programs)
        elif isinstance(criterion, (list, tuple)) and len(criterion) == 3:
            (pattern_1, raw_predicate, pattern_2) = criterion
            (predicate, negated) = normalize_predicate(raw_predicate)
            function = self.programs_of_negated_triple if negated else self.programs_of_triple
            resulting_programs.update(function(pattern_1, predicate, pattern_2))
        else:
            print_warning(f&#34;criterion {repr(criterion)} cannot be included or excluded.&#34;)
    return resulting_programs</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.impart_taxa"><code class="name flex">
<span>def <span class="ident">impart_taxa</span></span>(<span>self, <br>taxa: Set[TaxonName]<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Enrich the imparted knowledge with all the prefixes of the given taxa.</p>
<p>Add to <code>self.imparted_knowledge</code> the given taxa, along with all their prefixes. For
instance, imparting a taxon <code>a/b/c</code>, will impart taxa <code>a</code> and <code>a/b</code> too.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>taxa</code></strong> :&ensp;<code>TaxonNameSet</code></dt>
<dd>The concepts to be imparted along with their “super” concepts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L338-L351" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def impart_taxa(self, taxa: TaxonNameSet) -&gt; None:
    for taxon in taxa:
        edges = taxon.split(&#34;/&#34;)
        for i in range(len(edges)):
            prefix = &#34;/&#34;.join(edges[: i + 1])
            self.imparted_knowledge.add(TaxonName(prefix))</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.include_programs"><code class="name flex">
<span>def <span class="ident">include_programs</span></span>(<span>self, <br>programs: Set[ProgramPath]<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Deselect the programs not found among the given ones.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>ProgramPathSet</code></dt>
<dd>The set of programs to keep (provided they are already in
<code>self.selected_programs</code>). All other programs of <code>self.selected_programs</code> will be
filtered out.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L353-L361" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def include_programs(self, programs: ProgramPathSet) -&gt; None:
    self.selected_programs.intersection_update(programs)</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.exclude_programs"><code class="name flex">
<span>def <span class="ident">exclude_programs</span></span>(<span>self, <br>programs: Set[ProgramPath], <br>follow: bool<br>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Deselect the programs found among the given ones or (optionally) importing them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>ProgramPathSet</code></dt>
<dd>The set of programs to exclude.</dd>
<dt><strong><code>follow</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, exclude also all programs which import (either directly or
by transitivity) at least one member of the given <code>programs</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L363-L374" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def exclude_programs(self, programs: ProgramPathSet, follow: bool) -&gt; None:
    self.selected_programs.difference_update(programs)
    if follow:
        for program in programs:
            self.selected_programs.difference_update(self.db_exportations.get(program, {}))</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_of_triple"><code class="name flex">
<span>def <span class="ident">programs_of_triple</span></span>(<span>self, <br>taxon_pattern_1: str, <br>predicate: Callable[[Tuple[int, int], Tuple[int, int]], bool], <br>taxon_pattern_2: str<br>) ‑> Set[ProgramPath]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the programs where two given taxa satisfy a given predicate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>taxon_pattern_1</code></strong> :&ensp;<code>str</code></dt>
<dd>A regular expression pattern matching the “subject” of the
semantic triple.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Predicate</code></dt>
<dd>the predicate of the semantic triple, always expressed in
positive form.</dd>
<dt><strong><code>taxon_pattern_2</code></strong> :&ensp;<code>str</code></dt>
<dd>A regular expression pattern matching the ”object” of the
semantic triple.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgramPathSet</code></dt>
<dd>The programs featuring at least one span <code>s_1</code> of <code>taxon_1</code> and one
span <code>s_2</code> of <code>taxon_2</code> for which <code>predicate(s_1, s_2)</code> is verified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L378-L409" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_of_triple(
    self,
    taxon_pattern_1: str,
    predicate: Predicate,
    taxon_pattern_2: str,
) -&gt; ProgramPathSet:
    taxa_1 = self.taxa_of_pattern(taxon_pattern_1)
    taxa_2 = self.taxa_of_pattern(taxon_pattern_2)
    programs_1 = self.programs_of_taxa(taxa_1)
    programs_2 = self.programs_of_taxa(taxa_2)
    result: ProgramPathSet = set()
    for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
        spans = self.db_programs[program][&#34;taxa&#34;]
        for (span_1, span_2) in self.iterate_on_spans(spans, taxa_1, taxa_2):
            if predicate(span_1, span_2):
                result.add(program)
                break
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_of_negated_triple"><code class="name flex">
<span>def <span class="ident">programs_of_negated_triple</span></span>(<span>self, <br>taxon_pattern_1: str, <br>predicate: Callable[[Tuple[int, int], Tuple[int, int]], bool], <br>taxon_pattern_2: str<br>) ‑> Set[ProgramPath]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the programs where the given predicate is not satisfied.</p>
<h2 id="args">Args</h2>
<p>The same arguments as <code><a title="paroxython.filter_programs.ProgramFilter.programs_of_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_triple">ProgramFilter.programs_of_triple()</a></code>, including the fact that the
predicate is expressed in <strong>positive</strong> form.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgramPathSet</code></dt>
<dd>The set of programs which feature at least one taxon matching
<code>taxon_pattern_1</code>, and such that, for any
span <code>s_1</code> of such a taxon, there exists
no span <code>s_2</code> of a taxon matching <code>taxon_pattern_2</code> for which <code>predicate(s_1, s_2)</code>
is verified.</dd>
</dl>
<h2 id="details">Details</h2>
<p>See the <a href="user_manual/index.html#general-semantics-of-the-negation">pipeline documentation</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L411-L445" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_of_negated_triple(
    self,
    taxon_pattern_1: str,
    predicate: Predicate,
    taxon_pattern_2: str,
) -&gt; ProgramPathSet:
    taxa_1 = self.taxa_of_pattern(taxon_pattern_1)
    taxa_2 = self.taxa_of_pattern(taxon_pattern_2)
    programs_1 = self.programs_of_taxa(taxa_1)
    programs_2 = self.programs_of_taxa(taxa_2)
    result: ProgramPathSet = programs_1  # by default, keep all programs featuring taxon_1
    for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
        spans = self.db_programs[program][&#34;taxa&#34;]
        exists_span_2_satisfying_predicate: Dict[Tuple, bool] = defaultdict(bool)
        for (span_1, span_2) in self.iterate_on_spans(spans, taxa_1, taxa_2):
            exists_span_2_satisfying_predicate[tuple(span_1)] |= predicate(span_1, span_2)
        if all(exists_span_2_satisfying_predicate.values()):
            # for any span_1, there is at least one span_2 such that predicate(span_1, span_2)
            result.remove(program)
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.iterate_on_spans"><code class="name flex">
<span>def <span class="ident">iterate_on_spans</span></span>(<span>self, <br>spans: Dict[TaxonName, List[Tuple[int, int]]], <br>taxa_1: Set[TaxonName], <br>taxa_2: Set[TaxonName]<br>) ‑> Iterator</span>
</code></dt>
<dd>
<div class="desc"><p>Generate all relevant couples of spans for the given “subject” and ”object” taxa.</p>
<h2 id="description">Description</h2>
<p>This private function is invoked by <code><a title="paroxython.filter_programs.ProgramFilter.programs_of_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_triple">ProgramFilter.programs_of_triple()</a></code> and
<code><a title="paroxython.filter_programs.ProgramFilter.programs_of_negated_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_negated_triple">ProgramFilter.programs_of_negated_triple()</a></code> to enumerate the couples of spans on which
a condition of the form : “<code>subject_span</code> <code>predicate</code> <code>object_span</code>” will be evaluated.
Initially, such a condition is expressed by the user as: “<code>subject_pattern</code> <code>predicate</code>
<code>object_pattern</code>”. Both patterns may match several taxa and, in a given program, each
taxon can occur on several different or even identical spans. Ultimately, the predicate
expresses a relation between two spans.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spans</code></strong> :&ensp;<code>TaxaPoorSpans</code></dt>
<dd>The dictionary of the taxa featured by a certain program,
each taxon being associated with a list of poor spans (“poor” meaning that they
contain no other information than the numbers of the first and last line of a taxon
occurrence).</dd>
<dt><strong><code>taxa_1</code></strong> :&ensp;<code>TaxonNameSet</code></dt>
<dd>The various “subject” taxa of the semantic triple.</dd>
<dt><strong><code>taxa_2</code></strong> :&ensp;<code>TaxonNameSet</code></dt>
<dd>The various “object” taxa of the semantic triple.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[PoorSpan]</code></dt>
<dd>Couples of poor spans, in no particular order.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Consider a program featuring taxa <code>t1</code>, <code>t2</code>, <code>t3</code> and <code>t4</code> on the following spans:</p>
<pre><code class="python-repl">&gt;&gt;&gt; spans = {
...      &quot;t1&quot;: [(1, 1), (1, 1), (1, 2)],
...      &quot;t2&quot;: [(2, 3), (1, 2)],
...      &quot;t3&quot;: [(3, 3)],
...      &quot;t4&quot;: [(4, 4)],
... }
</code></pre>
<p>Note that <code>t1</code> occurs twice on span <code>(1, 1)</code>, and that <code>t1</code> and <code>t2</code> have span <code>(1, 2)</code>
in common.</p>
<p>Suppose first that the sets <code>taxa_1</code> and <code>taxa_2</code> have no common taxa. In this
case, the couples of spans on which to check the predicate are obtained by a simple
cross-product, e.g.:</p>
<pre><code class="python-repl">&gt;&gt;&gt; iterate_on_spans(spans, {&quot;t1&quot;, &quot;t2&quot;}, {&quot;t3&quot;, &quot;t4&quot;})
((1, 1), (3, 3))  # t1 (1) ⨉ t3
((1, 1), (3, 3))  # t1 (2) ⨉ t3
((1, 2), (3, 3))  # t1 (3) ⨉ t3
((1, 1), (4, 4))  # t1 (1) ⨉ t4
((1, 1), (4, 4))  # t1 (2) ⨉ t4
((1, 2), (4, 4))  # t1 (3) ⨉ t4
((2, 3), (3, 3))  # t2 (1) ⨉ t3
((1, 2), (3, 3))  # t2 (2) ⨉ t3
((2, 3), (4, 4))  # t2 (1) ⨉ t4
((1, 2), (4, 4))  # t2 (2) ⨉ t4
</code></pre>
<p>Suppose now that the sets <code>taxa_1</code> and <code>taxa_2</code> have <code>t1</code> in common. In that case,
we must suppress the diagonal of the cross-product, which not only carries zero useful
information, but will make certain conditions fail. For instance, if we seek to include
all the programs <em>not</em> featuring two multiplications on the same line, the condition
will be something like: “no multiplication is featured on the same line than another
one”. Keeping the diagonal would add “or itself“ to the previous condition. Since any
taxon is obviously featured on the same line than itself, no program would satisfy the
condition.</p>
<p>In the example below, note which lines are suppressed, and which are kept (particularly
for <code>((1, 1), (1, 1))</code>):</p>
<pre><code class="python-repl">&gt;&gt;&gt; iterate_on_spans(spans, {&quot;t1&quot;, &quot;t2&quot;}, {&quot;t1&quot;, &quot;t3&quot;})
# ((1, 1), (1, 1))  # t1 (1) ⨉ t1 (1) (not generated)
  ((1, 1), (1, 1))  # t1 (1) ⨉ t1 (2)
  ((1, 1), (1, 2))  # t1 (1) ⨉ t1 (3)
  ((1, 1), (1, 1))  # t1 (2) ⨉ t1 (1)
# ((1, 1), (1, 1))  # t1 (2) ⨉ t1 (2) (not generated)
  ((1, 1), (1, 2))  # t1 (2) ⨉ t1 (3)
  ((1, 2), (1, 1))  # t1 (3) ⨉ t1 (1)
  ((1, 2), (1, 1))  # t1 (3) ⨉ t1 (2)
# ((1, 2), (1, 2))  # t1 (3) ⨉ t1 (3) (not generated)
  ((1, 1), (3, 3))  # t1 (1) ⨉ t3
  ((1, 1), (3, 3))  # t1 (2) ⨉ t3
  ((1, 2), (3, 3))  # t1 (3) ⨉ t3
  ((2, 3), (1, 1))  # t2 (1) ⨉ t1 (1)
  ((2, 3), (1, 1))  # t2 (1) ⨉ t1 (2)
  ((2, 3), (1, 2))  # t2 (1) ⨉ t1 (3)
  ((1, 2), (1, 1))  # t2 (2) ⨉ t1 (1)
  ((1, 2), (1, 1))  # t2 (2) ⨉ t1 (2)
  ((1, 2), (1, 2))  # t2 (2) ⨉ t1 (3)
  ((2, 3), (3, 3))  # t2 (1) x t3
  ((1, 2), (3, 3))  # t2 (2) x t3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L447-L542" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def iterate_on_spans(
    self,  # declared as an instance method to prevent pdoc3 from misplacing its documentation.
    spans: TaxaPoorSpans,
    taxa_1: TaxonNameSet,
    taxa_2: TaxonNameSet,
) -&gt; Iterator:
    for (taxon_1, taxon_2) in product(taxa_1, taxa_2):
        if taxon_1 in spans and taxon_2 in spans:
            if taxon_1 == taxon_2:  # exclude diagonal from iteration
                yield from permutations(spans[taxon_1], 2)
            else:
                yield from product(spans[taxon_1], spans[taxon_2])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Paroxython Home" href="index.html">
<img src="https://laowantong.github.io/paroxython/resources/logo.png" alt="Paroxython logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="paroxython" href="index.html">paroxython</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="paroxython.filter_programs.ProgramFilter" href="#paroxython.filter_programs.ProgramFilter">ProgramFilter</a></code></h4>
<ul class="">
<li><code><a title="paroxython.filter_programs.ProgramFilter.__init__" href="#paroxython.filter_programs.ProgramFilter.__init__">__init__</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.define_shortcuts" href="#paroxython.filter_programs.ProgramFilter.define_shortcuts">define_shortcuts</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.init_filter_state" href="#paroxython.filter_programs.ProgramFilter.init_filter_state">init_filter_state</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.add_imported_taxa" href="#paroxython.filter_programs.ProgramFilter.add_imported_taxa">add_imported_taxa</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.taxa_of_pattern" href="#paroxython.filter_programs.ProgramFilter.taxa_of_pattern">taxa_of_pattern</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_of_pattern" href="#paroxython.filter_programs.ProgramFilter.programs_of_pattern">programs_of_pattern</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.taxa_of_programs" href="#paroxython.filter_programs.ProgramFilter.taxa_of_programs">taxa_of_programs</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_of_taxa" href="#paroxython.filter_programs.ProgramFilter.programs_of_taxa">programs_of_taxa</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.update_filter" href="#paroxython.filter_programs.ProgramFilter.update_filter">update_filter</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_and_taxa_of_patterns" href="#paroxython.filter_programs.ProgramFilter.programs_and_taxa_of_patterns">programs_and_taxa_of_patterns</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_or_taxa_of_patterns" href="#paroxython.filter_programs.ProgramFilter.programs_or_taxa_of_patterns">programs_or_taxa_of_patterns</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_of_criteria" href="#paroxython.filter_programs.ProgramFilter.programs_of_criteria">programs_of_criteria</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.impart_taxa" href="#paroxython.filter_programs.ProgramFilter.impart_taxa">impart_taxa</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.include_programs" href="#paroxython.filter_programs.ProgramFilter.include_programs">include_programs</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.exclude_programs" href="#paroxython.filter_programs.ProgramFilter.exclude_programs">exclude_programs</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_of_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_triple">programs_of_triple</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_of_negated_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_negated_triple">programs_of_negated_triple</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.iterate_on_spans" href="#paroxython.filter_programs.ProgramFilter.iterate_on_spans">iterate_on_spans</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>